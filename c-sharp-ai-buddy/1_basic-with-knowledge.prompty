---
name: C# AI Buddy
description: |
  🤖 你的 C# 夥伴 — C# AI Buddy 現已上線！
  💻 我隨時準備解答你對 C# 的問題，提供程式碼最佳化建議，助你快速掌握這門強大的程式語言。
  🚀 無論你是初學者還是資深開發者，C# AI Buddy 都將成為你開發旅程中不可或缺的得力助手！
model:
  configuration:
    name: claude-3-5-sonnet-latest
sample:
  BOT_USER_INPUT: |
    教我 DI 依頼注入
  knowledge: |
    [
    {
        "output": "URL: https://learn.microsoft.com/zh-tw/aspnet/core/fundamentals/\nTITLE: ASP.NET Core 基本概念的概觀\nCONTENT: \n\t\n\t\t跳到主要內容\n\n\t\t\n\t\t\t\t已不再支援此瀏覽器。\n\t\t\t\t請升級至 Microsoft Edge，以利用最新功能、安全性更新和技術支援。\n\t\t\t\t\n\t\t\t\n\t\t\n\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\n\n\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tASP.NET Core 基本概念的概觀\n\t\t\t\t\t\t\t\t\t\t\t發行項11/14/2024\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t本文內容\n\t\t\t\t\t\t\t\t\t\t\n注意\n這不是這篇文章的最新版本。 如需目前的版本，請參閱 本文的 .NET 9 版本。\n\n\n\n重要\n這些發行前產品的相關資訊在產品正式發行前可能會有大幅修改。 Microsoft 對此處提供的資訊，不做任何明確或隱含的瑕疵擔保。\n如需目前的版本，請參閱 本文的 .NET 9 版本。\n\n\n\n本文提供建置 ASP.NET Core 應用程式的基本概念概觀，包括相依性插入 (DI)、設定、中介軟體等等。\n如需 Blazor 基本概念指引，這會新增或取代本文中的指導方針，請參閱 ASP.NET Core Blazor 基本概念。\nProgram.cs\n使用 Web 範本建立的 ASP.NET Core 應用程式包含 Program.cs 檔案中的應用程式啟動程式碼。 \n              Program.cs 檔案位於下列位置：\n\n已設定應用程式所需的服務。\n應用程式的要求處理管線是定義為一系列中介軟體元件。\n\n下列應用程式啟動程式代碼支援數種應用程式類型：\n\n\n              \n              Blazor Web Apps\n\n              \n              Razor Pages\n\n              MVC 控制器與檢視\n\n              Web API 與控制器\n\n              最小 web API\n\nusing WebAll.Components;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorComponents()\n    .AddInteractiveServerComponents();\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseAuthorization();\n\napp.MapGet(\"/hi\", () => \"Hello!\");\n\napp.MapDefaultControllerRoute();\napp.MapRazorPages();\n\napp.MapRazorComponents<App>()\n    .AddInteractiveServerRenderMode();\n\napp.UseAntiforgery();\n\napp.Run();\n相依性插入 (服務)\nASP.NET Core 功能內建的 相依注入 （DI），讓設定好的服務能在整個應用程式中使用。 在上述程式碼中，服務會新增至具有 WebApplicationBuilder.Services、builder.Services 的 DI 容器。 具現化 WebApplicationBuilder 時，會自動新增許多 架構提供的服務項目。 \n              builder 是下列程式碼中的 WebApplicationBuilder：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n在上述程式代碼中，CreateBuilder 將設定、記錄和 許多其他服務 至 DI 容器。 DI 架構會在運行時間提供要求服務的實例。\n下列程式代碼會將自訂 DbContext 和 Blazor 元件新增至 DI 容器：\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddDbContextFactory<BlazorWebAppMoviesContext>(options =>\n    options.UseSqlServer(builder.Configuration.GetConnectionString(\"MoviesContext\") \n        ?? throw new InvalidOperationException(\"Connection string not found.\")));\n\nbuilder.Services.AddQuickGridEntityFrameworkAdapter();\n\nbuilder.Services.AddDatabaseDeveloperPageExceptionFilter();\n\n// Add services to the container.\nbuilder.Services.AddRazorComponents()\n    .AddInteractiveServerComponents();\n\nvar app = builder.Build();\n\n在 Blazor Web App中，服務通常會在執行時從 DI 解析，方法是在 Razor 元件中使用 @inject 指令，如下列範例所示：\n@page \"/movies\"\n@rendermode InteractiveServer\n@using Microsoft.EntityFrameworkCore\n@using Microsoft.AspNetCore.Components.QuickGrid\n@using BlazorWebAppMovies.Models\n@using BlazorWebAppMovies.Data\n@implements IAsyncDisposable\n@inject IDbContextFactory<BlazorWebAppMovies.Data.BlazorWebAppMoviesContext> DbFactory\n\n<PageTitle>Index</PageTitle>\n\n<h1>Index</h1>\n\n<div>\n    <input type=\"search\" @bind=\"titleFilter\" @bind:event=\"oninput\" />\n</div>\n\n<p>\n    <a href=\"movies/create\">Create New</a>\n</p>\n\n<QuickGrid Class=\"table\" Items=\"FilteredMovies\" Pagination=\"pagination\">\n    <PropertyColumn Property=\"movie => movie.Title\" Sortable=\"true\" />\n    <PropertyColumn Property=\"movie => movie.ReleaseDate\" Title=\"Release Date\" />\n    <PropertyColumn Property=\"movie => movie.Genre\" />\n    <PropertyColumn Property=\"movie => movie.Price\" />\n    <PropertyColumn Property=\"movie => movie.Rating\" />\n\n    <TemplateColumn Context=\"movie\">\n        <a href=\"@($\"movies/edit?id={movie.Id}\")\">Edit</a> |\n        <a href=\"@($\"movies/details?id={movie.Id}\")\">Details</a> |\n        <a href=\"@($\"movies/delete?id={movie.Id}\")\">Delete</a>\n    </TemplateColumn>\n</QuickGrid>\n\n<Paginator State=\"pagination\" />\n\n@code {\n    private BlazorWebAppMoviesContext context = default!;\n    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };\n    private string titleFilter = string.Empty;\n\n    private IQueryable<Movie> FilteredMovies =>\n        context.Movie.Where(m => m.Title!.Contains(titleFilter));\n\n    protected override void OnInitialized()\n    {\n        context = DbFactory.CreateDbContext();\n    }\n\n    public async ValueTask DisposeAsync() => await context.DisposeAsync();\n}\n\n在上述程式代碼中：\n\n使用 @inject 指示詞。\n服務會在 OnInitialized 方法中解析，並指派給 context 變數。\n\n              context 服務創建 FilteredMovie 清單。\n\n另一種從 DI 解析服務的方法是透過建構子注入。 下列 Razor Pages 程式代碼會使用建構函式插入解析資料庫內容和 DI 的記錄器：\npublic class IndexModel : PageModel\n{\n    private readonly RazorPagesMovieContext _context;\n    private readonly ILogger<IndexModel> _logger;\n\n    public IndexModel(RazorPagesMovieContext context, ILogger<IndexModel> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public IList<Movie> Movie { get;set; }\n\n    public async Task OnGetAsync()\n    {\n        _logger.LogInformation(\"IndexModel OnGetAsync.\");\n        Movie = await _context.Movie.ToListAsync();\n    }\n}\n\n在上述程式代碼中，IndexModel 建構函式會採用類型為 RazorPagesMovieContext的參數，其會在運行時間解析為 _context 變數。 內容物件可用來在 OnGetAsync 方法中建立電影清單。\n如需詳細資訊，請參閱 ASP.NET Core Blazor 相依性注入 和 ASP.NET Core中的相依性注入。\n中介軟體\n要求處理管線由一系列中介軟體元件所組成。 每個元件會在 HttpContext 上執行操作，並叫用管線中下一個中介軟體或終止要求。\n依照慣例，中介軟體元件會透過叫用 Use{Feature} 延伸模組方法來新增至管線。 下列程式代碼說明如何使用名為 Use{Feature} 的方法，將中間件新增至應用程式：\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddDbContextFactory<BlazorWebAppMoviesContext>(options =>\n    options.UseSqlServer(builder.Configuration.GetConnectionString(\"MoviesContext\") \n        ?? throw new InvalidOperationException(\"Connection string not found.\")));\n\nbuilder.Services.AddQuickGridEntityFrameworkAdapter();\n\nbuilder.Services.AddDatabaseDeveloperPageExceptionFilter();\n\n// Add services to the container.\nbuilder.Services.AddRazorComponents()\n    .AddInteractiveServerComponents();\n\nvar app = builder.Build();\n\nusing (var scope = app.Services.CreateScope())\n{\n    var services = scope.ServiceProvider;\n\n    SeedData.Initialize(services);\n}\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\", createScopeForErrors: true);\n    app.UseHsts();\n    app.UseMigrationsEndPoint();\n}\napp.UseHttpsRedirection();\n\napp.UseAntiforgery();\n\napp.MapStaticAssets();\napp.MapRazorComponents<App>()\n    .AddInteractiveServerRenderMode();\n\napp.Run();\n\n如需詳細資訊，請參閱 ASP.NET Core 中介軟體。\nHost\n在啟動時，ASP.NET Core 應用程式會建置一個「主機」。 主機會封裝所有應用程式的資源，例如：\n\nHTTP 伺服器實作\n中介軟體元件\n記錄\n相依性插入 (服務)\n組態\n\n有三個不同的主機能夠執行 ASP.NET Core 應用程式：\n\n\n              ASP.NET Core WebApplication，也稱為最小主機\n結合 ASP.NET Core  的 ConfigureWebHostDefaults\n\n              ASP.NET Core WebHost\n\n建議使用 ASP.NET Core WebApplication 和 WebApplicationBuilder 類型，並用於所有 ASP.NET Core 範本中。 \n              WebApplication 的行為類似於 .NET 泛型主機，並公開許多相同的介面，但需要較少的回呼才能設定。 ASP.NET Core WebHost 僅適用於回溯相容性。\n下列範例會具現化 WebApplication，並將它指派給名為 app的變數：\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddDbContextFactory<BlazorWebAppMoviesContext>(options =>\n    options.UseSqlServer(builder.Configuration.GetConnectionString(\"MoviesContext\") \n        ?? throw new InvalidOperationException(\"Connection string not found.\")));\n\nbuilder.Services.AddQuickGridEntityFrameworkAdapter();\n\nbuilder.Services.AddDatabaseDeveloperPageExceptionFilter();\n\n// Add services to the container.\nbuilder.Services.AddRazorComponents()\n    .AddInteractiveServerComponents();\n\nvar app = builder.Build();\n\n\n              WebApplicationBuilder.Build 方法會使用一組預設選項來設定主機，例如：\n\n使用 Kestrel 做為網頁伺服器，並啟用 IIS 整合。\n從 、環境變數、命令列引數及其他來源載入appsettings.json。\n將記錄輸出傳送到主控台及偵錯提供者。\n\n非 Web 案例\n一般主機可讓其他類型的應用程式使用跨領域架構延伸模組，例如記錄、相依性插入 （DI）、組態和應用程式存留期管理。 如需詳細資訊，請參閱 ASP.NET Core 中的 .NET 泛型主機，以及在 ASP.NET Core 中使用託管服務的背景工作。\n伺服器\nASP.NET Core 應用程式使用 HTTP 伺服器實作來接聽 HTTP 要求。 伺服器會把向應用程式發出的要求作為一組要求功能，合併成一個 HttpContext。\n\n\n\n\n              Windows\n\n\n\n              macOS\n\n\n\n              Linux\n\n\n\n\nASP.NET Core 隨附下列伺服器實作：\n\n\n              Kestrel 是跨平台的網頁伺服器。 \n              Kestrel 通常會使用 IIS 在反向 Proxy 設定中執行。 在 ASP.NET Core 2.0 和更新版本中，Kestrel 可作為直接公開至因特網的公開邊緣伺服器來執行。\n\n              IIS HTTP 伺服器則是適用於使用 IIS Windows 的伺服器。 透過此伺服器，ASP.NET Core 應用程式及 IIS 便可以在相同處理序中執行。\n\n              HTTP.sys 則是適用於並未搭配 IIS 使用 Windows 的伺服器。\n\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\n如需詳細資訊，請參閱在 ASP.NET Core 中實作網頁伺服器。\n組態\nASP.NET Core 提供組態架構，可從組態提供者的已排序集合中，以成對名稱和數值的形式取得設定。 您可以使用各種來源的內建組態提供者，例如 .json 檔案、.xml 檔案、環境變數及命令列引數。 撰寫自訂組態提供者以支援其他來源。\n根據預設，ASP.NET Core 應用程式會設定為從 appsettings.json、環境變數、命令列等進行讀取。 載入應用程式的組態時，來自環境變數的值會覆寫來自 appsettings.json 的值。\n為了在開發環境中管理機密設定數據，例如密碼，.NET Core 提供 Secret Manager。 針對生產祕密，我們建議使用 Azure Key Vault。\n如需詳細資訊，請參閱 ASP.NET Core 中的組態。\n環境\nASP.NET Core 中提供執行環境，例如 Development、Staging 和 Production。 透過設定 ASPNETCORE_ENVIRONMENT 環境變數來指定應用程式執行的環境。 ASP.NET Core 會在應用程式啟動時讀取環境變數，然後將值儲存在 IWebHostEnvironment 實作中。 您可在應用程式中透過相依性插入 (DI) 取得此實作。\n下列範例會在未於  環境中執行時，設定例外處理常式和 Development 中介軟體：\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\", createScopeForErrors: true);\n    app.UseHsts();\n    app.UseMigrationsEndPoint();\n}\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用多個環境 (部分機器翻譯)。\n記錄\nASP.NET Core 支援記錄 API，此 API 能與各種內建和第三方記錄提供者搭配使用。 可用的提供者包括：\n\n主控台\n偵錯\nWindows 上的事件追蹤\nWindows 事件記錄檔\nTraceSource\nAzure App Service\nAzure Application Insights\n\n若要建立記錄，ILogger<TCategoryName>請從相依性插入 (DI) 和通話記錄方法 (例如 LogInformation) 解析服務。 下列範例示範如何取得和使用 Blazor Web App中頁面 .razor 檔案中的記錄器。 當在 Program.cs中呼叫 CreateBuilder 方法時，記錄器物件及其控制台提供者會自動儲存在 DI 容器中。\n@page \"/weather\"\n@attribute [StreamRendering]\n@inject ILogger<Weather> Logger\n\n<PageTitle>Weather</PageTitle>\n\n<h1>Weather</h1>\n\n<p>This component demonstrates showing data and logging.</p>\n\n@if (forecasts == null)\n{\n    <p><em>Loading...</em></p>\n}\nelse\n{\n    <table class=\"table\">\n        <thead>\n            <tr>\n                <th>Date</th>\n                <th aria-label=\"Temperature in Celsius\">Temp. (C)</th>\n                <th aria-label=\"Temperature in Fahrenheit\">Temp. (F)</th>\n                <th>Summary</th>\n            </tr>\n        </thead>\n        <tbody>\n            @foreach (var forecast in forecasts)\n            {\n                <tr>\n                    <td>@forecast.Date.ToShortDateString()</td>\n                    <td>@forecast.TemperatureC</td>\n                    <td>@forecast.TemperatureF</td>\n                    <td>@forecast.Summary</td>\n                </tr>\n            }\n        </tbody>\n    </table>\n}\n\n@code {\n    private WeatherForecast[]? forecasts;\n\n    protected override async Task OnInitializedAsync()\n    {\n        // Simulate asynchronous loading to demonstrate streaming rendering\n       \n        await Task.Delay(500);\n\n        Logger.LogInformation(\"This is an information log message.\");\n        Logger.LogWarning(\"This is a warning log message.\");\n        Logger.LogError(\"This is an error log message.\");\n\n        var startDate = DateOnly.FromDateTime(DateTime.Now);\n        var summaries = new[] { \"Freezing\", \"Bracing\", \"Chilly\",\n            \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\" };\n        forecasts = Enumerable.Range(1, 5).Select(index => new WeatherForecast\n        {\n            Date = startDate.AddDays(index),\n            TemperatureC = Random.Shared.Next(-20, 55),\n            Summary = summaries[Random.Shared.Next(summaries.Length)]\n        }).ToArray();\n    }\n\n    private class WeatherForecast\n    {\n        public DateOnly Date { get; set; }\n        public int TemperatureC { get; set; }\n        public string? Summary { get; set; }\n        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);\n    }\n}\n\n如需詳細資料，請參閱 .NET Core 與 ASP.NET Core 中的記錄。\n路由\nASP.NET Core 中的路由是將連入要求對應至應用程式中特定端點的機制。 它可讓您定義對應至不同元件的 URL 模式，例如 Blazor 元件、Razor 頁面、MVC 控制器動作或中間件。\n\n              UseRouting(IApplicationBuilder) 方法會將路由中間件新增至要求管線。 此中間件會處理路由資訊，並判斷每個要求的適當端點。 除非您想要變更中間件處理的順序，否則您不需要明確呼叫 UseRouting。\n如需詳細資訊，請參閱 ASP.NET Core 和 ASP.NET Core  路由和瀏覽中的 路由。\n錯誤處理\nASP.NET Core 具有處理錯誤的內建功能，例如：\n\n開發人員例外狀況頁面\n自訂錯誤頁面\n靜態狀態碼頁面\n啟動例外狀況處理\n\n如需詳細資訊，請參閱處理 ASP.NET Core 中的錯誤。\n發出 HTTP 要求\n\n              IHttpClientFactory 的實作可用於建立 HttpClient 執行個體。 Factory：\n\n提供一個集中位置以便命名和設定邏輯 HttpClient 執行個體。 例如，註冊並設定 Github 用戶端以存取 GitHub。 註冊並設定預設用戶端以供其他用途使用。\n支援註冊及多個委派處理常式的鏈結，以用於建置傳出要求中介軟體管線。 此模式與 ASP.NET Core 的輸入中介軟體管線相似。 模式提供一個機制來管理 HTTP 要求的跨領域關注，包括快取、錯誤處理、序列化和記錄。\n與 Polly 整合，Polly 是一種熱門的協力廠商程式庫，用於進行暫時性的錯誤處理。\n管理基礎 HttpClientHandler 執行個體的共用和存留期，以避免在手動管理 HttpClient 存留期時，發生的常見 DNS 問題。\n針對透過處理站所建立之用戶端傳送的所有要求，新增可設定的記錄體驗 (透過 ILogger)。\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用 IHttpClientFactory 發出 HTTP 要求。\n內容根目錄\n內容根目錄是下列項目的基底路徑：\n\n裝載應用程式的可執行檔 (.exe)。\n構成應用程式 (.dll) 的已編譯組件。\n應用程式使用的內容檔案，例如：\n\n              Razor 檔案 (.cshtml、.razor)\n組態檔 (.json、.xml)\n資料檔案 (.db)\n\n\n\n              Web 根目錄，通常是 wwwroot 資料夾。\n\n在開發期間，內容根目錄預設為專案的根目錄。 此目錄也是應用程式內容檔案和 Web 根目錄的基底路徑。 指定不同的內容根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱內容根。\nWeb 根目錄\nWeb 根目錄是公用靜態資源檔的基底路徑，例如：\n\n樣式表單 (.css)\nJavaScript (.js)\n映像 (.png、.jpg)\n\n根據預設，靜態檔案只會處理來自 Web 根目錄及其子目錄的檔案。 Web 根路徑預設為 {content root}/wwwroot。 指定不同的 Web 根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱 Web 根目錄。\n防止在 wwwroot 中使用專案檔中的>來發佈檔案。 下列範例會防止在 wwwroot/local 及其子目錄中發佈內容：\n<ItemGroup>\n  <Content Update=\"wwwroot\\local\\**\\*.*\" CopyToPublishDirectory=\"Never\" />\n</ItemGroup>\n\n在 Razor.cshtml 檔案中，~/ 會指向 Web 根目錄。 開頭為 ~/ 的路徑稱為虛擬路徑。\n如需詳細資訊，請參閱 ASP.NET Core 中的靜態檔案。\n其他資源\n\n\n              ASP.NET Core Blazor 基本概念\n\n\n\n本文提供建置 ASP.NET Core 應用程式的基本概念概觀，包括相依性插入 (DI)、設定、中介軟體等等。\nProgram.cs\n使用 Web 範本建立的 ASP.NET Core 應用程式包含 Program.cs 檔案中的應用程式啟動程式碼。 \n              Program.cs 檔案位於下列位置：\n\n已設定應用程式所需的服務。\n應用程式的要求處理管線是定義為一系列中介軟體元件。\n\n下列應用程式啟動程式碼支援：\n\n\n              \n              Razor Pages\n\n              MVC 控制器與檢視\n\n              Web API 與控制器\n\n              最小 web API\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseAuthorization();\n\napp.MapGet(\"/hi\", () => \"Hello!\");\n\napp.MapDefaultControllerRoute();\napp.MapRazorPages();\n\napp.Run();\n相依性插入 (服務)\nASP.NET Core 包含相依性插入 (DI)，可讓整個應用程式使用所設定服務。 在上述程式碼中，服務會新增至具有 WebApplicationBuilder.Services、builder.Services 的 DI 容器。 具現化 WebApplicationBuilder 時，會新增許多架構所提供的服務。 \n              builder 是下列程式碼中的 WebApplicationBuilder：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n在上述反白顯示的程式碼中，builder 已將組態、記錄和許多其他服務新增至 DI 容器。\n下列程式碼會將 Razor Pages、具有檢視的 MVC 控制器，以及自訂的 DbContext 新增至 DI 容器：\nusing Microsoft.EntityFrameworkCore;\nusing RazorPagesMovie.Data;\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nbuilder.Services.AddDbContext<RazorPagesMovieContext>(options =>\n   options.UseSqlServer(builder.Configuration.GetConnectionString(\"RPMovieContext\")));\n\nvar app = builder.Build();\n\n通常會使用建構函式插入從 DI 解析服務。 DI 架構會在執行階段提供此服務的執行個體。\n下列程式碼會使用建構函式插入，從 DI 解析資料庫內容和記錄器：\npublic class IndexModel : PageModel\n{\n    private readonly RazorPagesMovieContext _context;\n    private readonly ILogger<IndexModel> _logger;\n\n    public IndexModel(RazorPagesMovieContext context, ILogger<IndexModel> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public IList<Movie> Movie { get;set; }\n\n    public async Task OnGetAsync()\n    {\n        _logger.LogInformation(\"IndexModel OnGetAsync.\");\n        Movie = await _context.Movie.ToListAsync();\n    }\n}\n中介軟體\n要求處理管線由一系列中介軟體元件所組成。 每個元件會在 HttpContext 上執行操作，並叫用管線中下一個中介軟體或終止要求。\n依照慣例，中介軟體元件會透過叫用 Use{Feature} 延伸模組方法來新增至管線。 下列程式碼中會將新增至應用程式的中介軟體反白顯示：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseAuthorization();\n\napp.MapGet(\"/hi\", () => \"Hello!\");\n\napp.MapDefaultControllerRoute();\napp.MapRazorPages();\n\napp.Run();\n\n如需詳細資訊，請參閱 ASP.NET Core 中介軟體。\nHost\n在啟動時，ASP.NET Core 應用程式會建置一個「主機」。 主機會封裝所有應用程式的資源，例如：\n\nHTTP 伺服器實作\n中介軟體元件\n記錄\n相依性插入 (服務)\n組態\n\n有三個不同的主機能夠執行 ASP.NET Core 應用程式：\n\n\n              ASP.NET Core WebApplication，也稱為最小主機\n結合 ASP.NET Core  的 ConfigureWebHostDefaults\n\n              ASP.NET Core WebHost\n\n建議使用 ASP.NET Core WebApplication 和 WebApplicationBuilder 類型，並用於所有 ASP.NET Core 範本。 \n              WebApplication 的運作方式與 .NET 泛型主機類似，並公開許多相同的介面，但需要較少的回呼進行設定。 ASP.NET Core WebHost 僅適用於回溯相容性。\n下列範例會具現化 WebApplication：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n\n              WebApplicationBuilder.Build 方法會使用一組預設選項來設定主機，例如：\n\n使用 Kestrel 做為網頁伺服器，並啟用 IIS 整合。\n從 、環境變數、命令列引數及其他來源載入appsettings.json。\n將記錄輸出傳送到主控台及偵錯提供者。\n\n非 Web 案例\n一般主機允許其他類型的應用程式，使用交叉剪輯架構延伸模組，例如記錄、相依性插入 (DI)、設定與應用程式存留期管理。 如需詳細資訊，請參閱 ASP.NET Core 中的 .NET 泛型主機，以及在 ASP.NET Core 中使用託管服務的背景工作。\n伺服器\nASP.NET Core 應用程式使用 HTTP 伺服器實作來接聽 HTTP 要求。 伺服器會把向應用程式發出的要求作為一組要求功能，合併成一個 HttpContext。\n\n\n\n\n              Windows\n\n\n\n              macOS\n\n\n\n              Linux\n\n\n\n\nASP.NET Core 隨附下列伺服器實作：\n\n\n              Kestrel 是跨平台的網頁伺服器。 \n              Kestrel 通常會使用 IIS 在反向 Proxy 設定中執行。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。\n\n              IIS HTTP 伺服器則是適用於使用 IIS Windows 的伺服器。 透過此伺服器，ASP.NET Core 應用程式及 IIS 便可以在相同處理序中執行。\n\n              HTTP.sys 則是適用於並未搭配 IIS 使用 Windows 的伺服器。\n\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\n如需詳細資訊，請參閱在 ASP.NET Core 中實作網頁伺服器。\n組態\nASP.NET Core 提供組態架構，可從組態提供者的已排序集合中，以成對名稱和數值的形式取得設定。 您可以使用各種來源的內建組態提供者，例如 .json 檔案、.xml 檔案、環境變數及命令列引數。 撰寫自訂組態提供者以支援其他來源。\n根據預設，ASP.NET Core 應用程式會設定為從 appsettings.json、環境變數、命令列等進行讀取。 載入應用程式的組態時，來自環境變數的值會覆寫來自 appsettings.json 的值。\n針對管理保密組態資料 (例如密碼)，.NET Core 提供祕密管理員。 針對生產祕密，我們建議使用 Azure Key Vault。\n如需詳細資訊，請參閱 ASP.NET Core 中的組態。\n環境\nASP.NET Core 中提供執行環境，例如 Development、Staging 和 Production。 透過設定 ASPNETCORE_ENVIRONMENT 環境變數來指定應用程式執行的環境。 ASP.NET Core 會在應用程式啟動時讀取環境變數，然後將值儲存在 IWebHostEnvironment 實作中。 您可在應用程式中透過相依性插入 (DI) 取得此實作。\n下列範例會在未於  環境中執行時，設定例外處理常式和 Development 中介軟體：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseAuthorization();\n\napp.MapGet(\"/hi\", () => \"Hello!\");\n\napp.MapDefaultControllerRoute();\napp.MapRazorPages();\n\napp.Run();\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用多個環境 (部分機器翻譯)。\n記錄\nASP.NET Core 支援記錄 API，此 API 能與各種內建和第三方記錄提供者搭配使用。 可用的提供者包括：\n\n主控台\n偵錯\nWindows 上的事件追蹤\nWindows 事件記錄檔\nTraceSource\nAzure App Service\nAzure Application Insights\n\n若要建立記錄，ILogger<TCategoryName>請從相依性插入 (DI) 和通話記錄方法 (例如 LogInformation) 解析服務。 例如：\npublic class IndexModel : PageModel\n{\n    private readonly RazorPagesMovieContext _context;\n    private readonly ILogger<IndexModel> _logger;\n\n    public IndexModel(RazorPagesMovieContext context, ILogger<IndexModel> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public IList<Movie> Movie { get;set; }\n\n    public async Task OnGetAsync()\n    {\n        _logger.LogInformation(\"IndexModel OnGetAsync.\");\n        Movie = await _context.Movie.ToListAsync();\n    }\n}\n\n如需詳細資料，請參閱 .NET Core 與 ASP.NET Core 中的記錄。\n路由\n「路由」是一種對應到處理常式的 URL 模式。 處理常式通常是 Razor 頁面、MVC 控制器中的動作方法，或是中介軟體。 ASP.NET Core 路由可讓您控制您應用程式使用的 URL。\nASP.NET Core Web 應用程式範本所產生的下列程式碼會呼叫 UseRouting：\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddRazorPages();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapRazorPages();\n\napp.Run();\n\n如需詳細資訊，請參閱 ASP.NET Core 中的路線規劃。\n錯誤處理\nASP.NET Core 具有處理錯誤的內建功能，例如：\n\n開發人員例外狀況頁面\n自訂錯誤頁面\n靜態狀態碼頁面\n啟動例外狀況處理\n\n如需詳細資訊，請參閱處理 ASP.NET Core 中的錯誤。\n發出 HTTP 要求\n\n              IHttpClientFactory 的實作可用於建立 HttpClient 執行個體。 Factory：\n\n提供一個集中位置以便命名和設定邏輯 HttpClient 執行個體。 例如，註冊並設定 Github 用戶端以存取 GitHub。 註冊並設定預設用戶端以供其他用途使用。\n支援註冊及多個委派處理常式的鏈結，以用於建置傳出要求中介軟體管線。 此模式與 ASP.NET Core 的輸入中介軟體管線相似。 模式提供一個機制來管理 HTTP 要求的跨領域關注，包括快取、錯誤處理、序列化和記錄。\n與 Polly 整合，Polly 是一種熱門的協力廠商程式庫，用於進行暫時性的錯誤處理。\n管理基礎 HttpClientHandler 執行個體的共用和存留期，以避免在手動管理 HttpClient 存留期時，發生的常見 DNS 問題。\n針對透過處理站所建立之用戶端傳送的所有要求，新增可設定的記錄體驗 (透過 ILogger)。\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用 IHttpClientFactory 發出 HTTP 要求。\n內容根目錄\n內容根目錄是下列項目的基底路徑：\n\n裝載應用程式的可執行檔 (.exe)。\n構成應用程式 (.dll) 的已編譯組件。\n應用程式使用的內容檔案，例如：\n\n              Razor 檔案 (.cshtml、.razor)\n組態檔 (.json、.xml)\n資料檔案 (.db)\n\n\n\n              Web 根目錄，通常是 wwwroot 資料夾。\n\n在開發期間，內容根目錄預設為專案的根目錄。 此目錄也是應用程式內容檔案和 Web 根目錄的基底路徑。 指定不同的內容根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱內容根。\nWeb 根目錄\nWeb 根目錄是公用靜態資源檔的基底路徑，例如：\n\n樣式表單 (.css)\nJavaScript (.js)\n映像 (.png、.jpg)\n\n根據預設，靜態檔案只會處理來自 Web 根目錄及其子目錄的檔案。 Web 根路徑預設為 {content root}/wwwroot。 指定不同的 Web 根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱 Web 根目錄。\n防止在 wwwroot 中使用專案檔中的>來發佈檔案。 下列範例會防止在 wwwroot/local 及其子目錄中發佈內容：\n<ItemGroup>\n  <Content Update=\"wwwroot\\local\\**\\*.*\" CopyToPublishDirectory=\"Never\" />\n</ItemGroup>\n\n在 Razor.cshtml 檔案中，~/ 會指向 Web 根目錄。 開頭為 ~/ 的路徑稱為虛擬路徑。\n如需詳細資訊，請參閱 ASP.NET Core 中的靜態檔案。\n其他資源\n\n\n              WebApplicationBuilder 原始程式碼\n\n\n\n本文提供建置 ASP.NET Core 應用程式的基本概念概觀，包括相依性插入 (DI)、設定、中介軟體等等。\nStartup 類別\n\n              Startup 類別是：\n\n已設定應用程式所需的服務。\n應用程式的要求處理管線是定義為一系列中介軟體元件。\n\n以下是 Startup 類別範例：\npublic class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddDbContext<RazorPagesMovieContext>(options =>\n            options.UseSqlServer(Configuration.GetConnectionString(\"RazorPagesMovieContext\")));\n\n        services.AddControllersWithViews();\n        services.AddRazorPages();\n    }\n\n    public void Configure(IApplicationBuilder app)\n    {\n        app.UseHttpsRedirection();\n        app.UseStaticFiles();\n\n        app.UseRouting();\n\n        app.UseEndpoints(endpoints =>\n        {\n            endpoints.MapDefaultControllerRoute();\n            endpoints.MapRazorPages();\n        });\n    }\n}\n\n如需詳細資訊，請參閱 ASP.NET Core 中的應用程式啟動。\n相依性插入 (服務)\nASP.NET Core 包含內建的相依性插入 (DI) 架構，可讓整個應用程式使用所設定服務。 例如，記錄元件即為一項服務。\n設定 (或「註冊」) 服務的程式碼會新增至 Startup.ConfigureServices 方法。 例如：\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddDbContext<RazorPagesMovieContext>(options =>\n        options.UseSqlServer(Configuration.GetConnectionString(\"RazorPagesMovieContext\")));\n\n    services.AddControllersWithViews();\n    services.AddRazorPages();\n}\n\n通常會使用建構函式插入從 DI 解析服務。 類別會使用建構函式插入來宣告必要類型或介面的建構函式參數。 DI 架構會在執行階段提供此服務的執行個體。\n下列範例會使用建構函式插入從 DI 解析 RazorPagesMovieContext：\npublic class IndexModel : PageModel\n{\n    private readonly RazorPagesMovieContext _context;\n\n    public IndexModel(RazorPagesMovieContext context)\n    {\n        _context = context;\n    }\n\n    // ...\n\n    public async Task OnGetAsync()\n    {\n        Movies = await _context.Movies.ToListAsync();\n    }\n}\n\n如果內建的控制反轉 (IoC) 容器不符合應用程式的所有需求，則可以改用協力廠商 IoC 容器。\n如需詳細資訊，請參閱在 ASP.NET Core 中插入相依性。\n中介軟體\n要求處理管線由一系列中介軟體元件所組成。 每個元件會在 HttpContext 上執行操作，並叫用管線中下一個中介軟體或終止要求。\n依照慣例，中介軟體元件會透過叫用 Use... 方法中的 Startup.Configure 延伸模組方法來新增至管線。 例如，若要啟用靜態檔案轉譯，請呼叫 UseStaticFiles。\n下列範例會設定要求處理管線：\npublic void Configure(IApplicationBuilder app)\n{\n    app.UseHttpsRedirection();\n    app.UseStaticFiles();\n\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapDefaultControllerRoute();\n        endpoints.MapRazorPages();\n    });\n}\n\nASP.NET Core 內含一組豐富的內建中介軟體。 您也可以撰寫自訂中介軟體元件。\n如需詳細資訊，請參閱 ASP.NET Core 中介軟體。\nHost\n在啟動時，ASP.NET Core 應用程式會建置一個「主機」。 主機會封裝所有應用程式的資源，例如：\n\nHTTP 伺服器實作\n中介軟體元件\n記錄\n相依性插入 (服務)\n組態\n\n有兩個不同的主機：\n\n.NET 泛型主機\nASP.NET Core Web 主機\n\n建議使用 .NET 泛型主機。 ASP.NET Core Web 主機僅適用於回溯相容性。\n下列範例會建立 .NET 泛型主機：\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        CreateHostBuilder(args).Build().Run();\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureWebHostDefaults(webBuilder =>\n            {\n                webBuilder.UseStartup<Startup>();\n            });\n}\n\n\n              CreateDefaultBuilder 和 ConfigureWebHostDefaults 方法會使用一組預設選項來設定主機，例如：\n\n使用 Kestrel 做為網頁伺服器，並啟用 IIS 整合。\n從 appsettings.json、appsettings.{Environment}.json、環境變數、命令列引數及其他來源載入組態。\n將記錄輸出傳送到主控台及偵錯提供者。\n\n如需詳細資訊，請參閱 ASP.NET 中的 .NET 泛型主機。\n非 Web 案例\n一般主機允許其他類型的應用程式，使用交叉剪輯架構延伸模組，例如記錄、相依性插入 (DI)、設定與應用程式存留期管理。 如需詳細資訊，請參閱 ASP.NET Core 中的 .NET 泛型主機，以及在 ASP.NET Core 中使用託管服務的背景工作。\n伺服器\nASP.NET Core 應用程式使用 HTTP 伺服器實作來接聽 HTTP 要求。 伺服器會把向應用程式發出的要求作為一組要求功能，合併成一個 HttpContext。\n\n\n\n\n              Windows\n\n\n\n              macOS\n\n\n\n              Linux\n\n\n\n\nASP.NET Core 隨附下列伺服器實作：\n\n\n              Kestrel 是跨平台的網頁伺服器。 \n              Kestrel 通常會使用 IIS 在反向 Proxy 設定中執行。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。\n\n              IIS HTTP 伺服器則是適用於使用 IIS Windows 的伺服器。 透過此伺服器，ASP.NET Core 應用程式及 IIS 便可以在相同處理序中執行。\n\n              HTTP.sys 則是適用於並未搭配 IIS 使用 Windows 的伺服器。\n\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\n如需詳細資訊，請參閱在 ASP.NET Core 中實作網頁伺服器。\n組態\nASP.NET Core 提供組態架構，可從組態提供者的已排序集合中，以成對名稱和數值的形式取得設定。 您可以使用各種來源的內建組態提供者，例如 .json 檔案、.xml 檔案、環境變數及命令列引數。 撰寫自訂組態提供者以支援其他來源。\n根據預設，ASP.NET Core 應用程式會設定為從 appsettings.json、環境變數、命令列等進行讀取。 載入應用程式的組態時，來自環境變數的值會覆寫來自 appsettings.json 的值。\n讀取相關設定值的慣用方式是使用選項模式 (部分機器翻譯)。 如需詳細資訊，請參閱使用選項模式繫結階層式設定資料。\n針對管理保密組態資料 (例如密碼)，.NET Core 提供祕密管理員。 針對生產祕密，我們建議使用 Azure Key Vault。\n如需詳細資訊，請參閱 ASP.NET Core 中的組態。\n環境\n執行環境 (例如 Development、Staging 和 Production) 是 ASP.NET Core 中的第一級概念。 透過設定 ASPNETCORE_ENVIRONMENT 環境變數來指定應用程式執行的環境。 ASP.NET Core 會在應用程式啟動時讀取環境變數，然後將值儲存在 IWebHostEnvironment 實作中。 您可在應用程式中透過相依性插入 (DI) 取得此實作。\n下列範例會將應用程式設定為在 Development 環境中執行時，提供詳細的錯誤資訊：\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        app.UseExceptionHandler(\"/Error\");\n        app.UseHsts();\n    }\n\n    app.UseHttpsRedirection();\n    app.UseStaticFiles();\n\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapDefaultControllerRoute();\n        endpoints.MapRazorPages();\n    });\n}\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用多個環境 (部分機器翻譯)。\n記錄\nASP.NET Core 支援記錄 API，此 API 能與各種內建和第三方記錄提供者搭配使用。 可用的提供者包括：\n\n主控台\n偵錯\nWindows 上的事件追蹤\nWindows 事件記錄檔\nTraceSource\nAzure App Service\nAzure Application Insights\n\n若要建立記錄，ILogger<TCategoryName>請從相依性插入 (DI) 和通話記錄方法 (例如 LogInformation) 解析服務。 例如：\npublic class TodoController : ControllerBase\n{\n    private readonly ILogger _logger;\n\n    public TodoController(ILogger<TodoController> logger)\n    {\n        _logger = logger;\n    }\n\n    [HttpGet(\"{id}\", Name = \"GetTodo\")]\n    public ActionResult<TodoItem> GetById(string id)\n    {\n        _logger.LogInformation(LoggingEvents.GetItem, \"Getting item {Id}\", id);\n        \n        // Item lookup code removed.\n        \n        if (item == null)\n        {\n            _logger.LogWarning(LoggingEvents.GetItemNotFound, \"GetById({Id}) NOT FOUND\", id);\n            return NotFound();\n        }\n        \n        return item;\n    }\n}\n\n記錄方法 (例如 LogInformation) 支援任何數目的欄位。 這些欄位通常用來建構訊息 string，但有些記錄提供者會將這些欄位傳送至資料存放區做為個別欄位。 這項功能可讓記錄提供者實作 semantic logging (語意記錄)，又稱為 structured logging (結構化記錄)。\n如需詳細資料，請參閱 .NET Core 與 ASP.NET Core 中的記錄。\n路由\n「路由」是一種對應到處理常式的 URL 模式。 處理常式通常是 Razor 頁面、MVC 控制器中的動作方法，或是中介軟體。 ASP.NET Core 路由可讓您控制您應用程式使用的 URL。\n如需詳細資訊，請參閱 ASP.NET Core 中的路線規劃。\n錯誤處理\nASP.NET Core 具有處理錯誤的內建功能，例如：\n\n開發人員例外狀況頁面\n自訂錯誤頁面\n靜態狀態碼頁面\n啟動例外狀況處理\n\n如需詳細資訊，請參閱處理 ASP.NET Core 中的錯誤。\n發出 HTTP 要求\n\n              IHttpClientFactory 的實作可用於建立 HttpClient 執行個體。 Factory：\n\n提供一個集中位置以便命名和設定邏輯 HttpClient 執行個體。 例如，註冊並設定 Github 用戶端以存取 GitHub。 註冊並設定預設用戶端以供其他用途使用。\n支援註冊及多個委派處理常式的鏈結，以用於建置傳出要求中介軟體管線。 此模式與 ASP.NET Core 的輸入中介軟體管線相似。 模式提供一個機制來管理 HTTP 要求的跨領域關注，包括快取、錯誤處理、序列化和記錄。\n與 Polly 整合，Polly 是一種熱門的協力廠商程式庫，用於進行暫時性的錯誤處理。\n管理基礎 HttpClientHandler 執行個體的共用和存留期，以避免在手動管理 HttpClient 存留期時，發生的常見 DNS 問題。\n針對透過處理站所建立之用戶端傳送的所有要求，新增可設定的記錄體驗 (透過 ILogger)。\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用 IHttpClientFactory 發出 HTTP 要求。\n內容根目錄\n內容根目錄是下列項目的基底路徑：\n\n裝載應用程式的可執行檔 (.exe)。\n構成應用程式 (.dll) 的已編譯組件。\n應用程式使用的內容檔案，例如：\n\n              Razor 檔案 (.cshtml、.razor)\n組態檔 (.json、.xml)\n資料檔案 (.db)\n\n\n\n              Web 根目錄，通常是 wwwroot 資料夾。\n\n在開發期間，內容根目錄預設為專案的根目錄。 此目錄也是應用程式內容檔案和 Web 根目錄的基底路徑。 指定不同的內容根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱內容根。\nWeb 根目錄\nWeb 根目錄是公用靜態資源檔的基底路徑，例如：\n\n樣式表單 (.css)\nJavaScript (.js)\n映像 (.png、.jpg)\n\n根據預設，靜態檔案只會處理來自 Web 根目錄及其子目錄的檔案。 Web 根路徑預設為 {content root}/wwwroot。 指定不同的 Web 根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱 Web 根目錄。\n防止在 wwwroot 中使用專案檔中的>來發佈檔案。 下列範例會防止在 wwwroot/local 及其子目錄中發佈內容：\n<ItemGroup>\n  <Content Update=\"wwwroot\\local\\**\\*.*\" CopyToPublishDirectory=\"Never\" />\n</ItemGroup>\n\n在 Razor.cshtml 檔案中，tilde-slash (~/) 會指向 Web 根目錄。 開頭為 ~/ 的路徑稱為虛擬路徑。\n如需詳細資訊，請參閱 ASP.NET Core 中的靜態檔案。\n\n\n本文提供建置 ASP.NET Core 應用程式的基本概念概觀，包括相依性插入 (DI)、設定、中介軟體等等。\n如需 Blazor 基礎知識指引 (其會新增或取代此節點中的指引)，請參閱 ASP.NET Core Blazor 基本概念。\nProgram.cs\n使用 Web 範本建立的 ASP.NET Core 應用程式包含 Program.cs 檔案中的應用程式啟動程式碼。 \n              Program.cs 檔案位於下列位置：\n\n已設定應用程式所需的服務。\n應用程式的要求處理管線是定義為一系列中介軟體元件。\n\n下列應用程式啟動程式碼支援：\n\n\n              \n              Razor Pages\n\n              MVC 控制器與檢視\n\n              Web API 與控制器\n\n              最小 web API\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseAuthorization();\n\napp.MapGet(\"/hi\", () => \"Hello!\");\n\napp.MapDefaultControllerRoute();\napp.MapRazorPages();\n\napp.Run();\n相依性插入 (服務)\nASP.NET Core 包含相依性插入 (DI)，可讓整個應用程式使用所設定服務。 在上述程式碼中，服務會新增至具有 WebApplicationBuilder.Services、builder.Services 的 DI 容器。 具現化 WebApplicationBuilder 時，會新增許多架構所提供的服務。 \n              builder 是下列程式碼中的 WebApplicationBuilder：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n在上述反白顯示的程式碼中，builder 已將組態、記錄和許多其他服務新增至 DI 容器。\n下列程式碼會將 Razor Pages、具有檢視的 MVC 控制器，以及自訂的 DbContext 新增至 DI 容器：\nusing Microsoft.EntityFrameworkCore;\nusing RazorPagesMovie.Data;\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nbuilder.Services.AddDbContext<RazorPagesMovieContext>(options =>\n   options.UseSqlServer(builder.Configuration.GetConnectionString(\"RPMovieContext\")));\n\nvar app = builder.Build();\n\n通常會使用建構函式插入從 DI 解析服務。 DI 架構會在執行階段提供此服務的執行個體。\n下列程式碼會使用建構函式插入，從 DI 解析資料庫內容和記錄器：\npublic class IndexModel : PageModel\n{\n    private readonly RazorPagesMovieContext _context;\n    private readonly ILogger<IndexModel> _logger;\n\n    public IndexModel(RazorPagesMovieContext context, ILogger<IndexModel> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public IList<Movie> Movie { get;set; }\n\n    public async Task OnGetAsync()\n    {\n        _logger.LogInformation(\"IndexModel OnGetAsync.\");\n        Movie = await _context.Movie.ToListAsync();\n    }\n}\n中介軟體\n要求處理管線由一系列中介軟體元件所組成。 每個元件會在 HttpContext 上執行操作，並叫用管線中下一個中介軟體或終止要求。\n依照慣例，中介軟體元件會透過叫用 Use{Feature} 延伸模組方法來新增至管線。 下列程式碼中會將新增至應用程式的中介軟體反白顯示：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseAuthorization();\n\napp.MapGet(\"/hi\", () => \"Hello!\");\n\napp.MapDefaultControllerRoute();\napp.MapRazorPages();\n\napp.Run();\n\n如需詳細資訊，請參閱 ASP.NET Core 中介軟體。\nHost\n在啟動時，ASP.NET Core 應用程式會建置一個「主機」。 主機會封裝所有應用程式的資源，例如：\n\nHTTP 伺服器實作\n中介軟體元件\n記錄\n相依性插入 (服務)\n組態\n\n有三個不同的主機能夠執行 ASP.NET Core 應用程式：\n\n\n              ASP.NET Core WebApplication，也稱為最小主機\n結合 ASP.NET Core  的 ConfigureWebHostDefaults\n\n              ASP.NET Core WebHost\n\n建議使用 ASP.NET Core WebApplication 和 WebApplicationBuilder 類型，並用於所有 ASP.NET Core 範本。 \n              WebApplication 的運作方式與 .NET 泛型主機類似，並公開許多相同的介面，但需要較少的回呼進行設定。 ASP.NET Core WebHost 僅適用於回溯相容性。\n下列範例會具現化 WebApplication：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n\n              WebApplicationBuilder.Build 方法會使用一組預設選項來設定主機，例如：\n\n使用 Kestrel 做為網頁伺服器，並啟用 IIS 整合。\n從 、環境變數、命令列引數及其他來源載入appsettings.json。\n將記錄輸出傳送到主控台及偵錯提供者。\n\n非 Web 案例\n一般主機允許其他類型的應用程式，使用交叉剪輯架構延伸模組，例如記錄、相依性插入 (DI)、設定與應用程式存留期管理。 如需詳細資訊，請參閱 ASP.NET Core 中的 .NET 泛型主機，以及在 ASP.NET Core 中使用託管服務的背景工作。\n伺服器\nASP.NET Core 應用程式使用 HTTP 伺服器實作來接聽 HTTP 要求。 伺服器會把向應用程式發出的要求作為一組要求功能，合併成一個 HttpContext。\n\n\n\n\n              Windows\n\n\n\n              macOS\n\n\n\n              Linux\n\n\n\n\nASP.NET Core 隨附下列伺服器實作：\n\n\n              Kestrel 是跨平台的網頁伺服器。 \n              Kestrel 通常會使用 IIS 在反向 Proxy 設定中執行。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。\n\n              IIS HTTP 伺服器則是適用於使用 IIS Windows 的伺服器。 透過此伺服器，ASP.NET Core 應用程式及 IIS 便可以在相同處理序中執行。\n\n              HTTP.sys 則是適用於並未搭配 IIS 使用 Windows 的伺服器。\n\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\nASP.NET Core 提供 Kestrel 跨平台伺服器實作。 在 ASP.NET Core 2.0 或更新版本中，Kestrel 可以做為直接向網際網路公開的公眾 Edge Server 執行。 \n              Kestrel 通常會使用 Nginx 或 Apache 在反向 Proxy 設定中執行。\n\n\n\n如需詳細資訊，請參閱在 ASP.NET Core 中實作網頁伺服器。\n組態\nASP.NET Core 提供組態架構，可從組態提供者的已排序集合中，以成對名稱和數值的形式取得設定。 您可以使用各種來源的內建組態提供者，例如 .json 檔案、.xml 檔案、環境變數及命令列引數。 撰寫自訂組態提供者以支援其他來源。\n根據預設，ASP.NET Core 應用程式會設定為從 appsettings.json、環境變數、命令列等進行讀取。 載入應用程式的組態時，來自環境變數的值會覆寫來自 appsettings.json 的值。\n針對管理保密組態資料 (例如密碼)，.NET Core 提供祕密管理員。 針對生產祕密，我們建議使用 Azure Key Vault。\n如需詳細資訊，請參閱 ASP.NET Core 中的組態。\n環境\nASP.NET Core 中提供執行環境，例如 Development、Staging 和 Production。 透過設定 ASPNETCORE_ENVIRONMENT 環境變數來指定應用程式執行的環境。 ASP.NET Core 會在應用程式啟動時讀取環境變數，然後將值儲存在 IWebHostEnvironment 實作中。 您可在應用程式中透過相依性插入 (DI) 取得此實作。\n下列範例會在未於  環境中執行時，設定例外處理常式和 Development 中介軟體：\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRazorPages();\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseAuthorization();\n\napp.MapGet(\"/hi\", () => \"Hello!\");\n\napp.MapDefaultControllerRoute();\napp.MapRazorPages();\n\napp.Run();\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用多個環境 (部分機器翻譯)。\n記錄\nASP.NET Core 支援記錄 API，此 API 能與各種內建和第三方記錄提供者搭配使用。 可用的提供者包括：\n\n主控台\n偵錯\nWindows 上的事件追蹤\nWindows 事件記錄檔\nTraceSource\nAzure App Service\nAzure Application Insights\n\n若要建立記錄，ILogger<TCategoryName>請從相依性插入 (DI) 和通話記錄方法 (例如 LogInformation) 解析服務。 例如：\npublic class IndexModel : PageModel\n{\n    private readonly RazorPagesMovieContext _context;\n    private readonly ILogger<IndexModel> _logger;\n\n    public IndexModel(RazorPagesMovieContext context, ILogger<IndexModel> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public IList<Movie> Movie { get;set; }\n\n    public async Task OnGetAsync()\n    {\n        _logger.LogInformation(\"IndexModel OnGetAsync.\");\n        Movie = await _context.Movie.ToListAsync();\n    }\n}\n\n如需詳細資料，請參閱 .NET Core 與 ASP.NET Core 中的記錄。\n路由\n「路由」是一種對應到處理常式的 URL 模式。 處理常式通常是 Razor 頁面、MVC 控制器中的動作方法，或是中介軟體。 ASP.NET Core 路由可讓您控制您應用程式使用的 URL。\nASP.NET Core Web 應用程式範本所產生的下列程式碼會呼叫 UseRouting：\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddRazorPages();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (!app.Environment.IsDevelopment())\n{\n    app.UseExceptionHandler(\"/Error\");\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapRazorPages();\n\napp.Run();\n\n如需詳細資訊，請參閱 ASP.NET Core 中的路線規劃。\n錯誤處理\nASP.NET Core 具有處理錯誤的內建功能，例如：\n\n開發人員例外狀況頁面\n自訂錯誤頁面\n靜態狀態碼頁面\n啟動例外狀況處理\n\n如需詳細資訊，請參閱處理 ASP.NET Core 中的錯誤。\n發出 HTTP 要求\n\n              IHttpClientFactory 的實作可用於建立 HttpClient 執行個體。 Factory：\n\n提供一個集中位置以便命名和設定邏輯 HttpClient 執行個體。 例如，註冊並設定 Github 用戶端以存取 GitHub。 註冊並設定預設用戶端以供其他用途使用。\n支援註冊及多個委派處理常式的鏈結，以用於建置傳出要求中介軟體管線。 此模式與 ASP.NET Core 的輸入中介軟體管線相似。 模式提供一個機制來管理 HTTP 要求的跨領域關注，包括快取、錯誤處理、序列化和記錄。\n與 Polly 整合，Polly 是一種熱門的協力廠商程式庫，用於進行暫時性的錯誤處理。\n管理基礎 HttpClientHandler 執行個體的共用和存留期，以避免在手動管理 HttpClient 存留期時，發生的常見 DNS 問題。\n針對透過處理站所建立之用戶端傳送的所有要求，新增可設定的記錄體驗 (透過 ILogger)。\n\n如需詳細資訊，請參閱在 ASP.NET Core 中使用 IHttpClientFactory 發出 HTTP 要求。\n內容根目錄\n內容根目錄是下列項目的基底路徑：\n\n裝載應用程式的可執行檔 (.exe)。\n構成應用程式 (.dll) 的已編譯組件。\n應用程式使用的內容檔案，例如：\n\n              Razor 檔案 (.cshtml、.razor)\n組態檔 (.json、.xml)\n資料檔案 (.db)\n\n\n\n              Web 根目錄，通常是 wwwroot 資料夾。\n\n在開發期間，內容根目錄預設為專案的根目錄。 此目錄也是應用程式內容檔案和 Web 根目錄的基底路徑。 指定不同的內容根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱內容根。\nWeb 根目錄\nWeb 根目錄是公用靜態資源檔的基底路徑，例如：\n\n樣式表單 (.css)\nJavaScript (.js)\n映像 (.png、.jpg)\n\n根據預設，靜態檔案只會處理來自 Web 根目錄及其子目錄的檔案。 Web 根路徑預設為 {content root}/wwwroot。 指定不同的 Web 根目錄，方法是在建置主機時設定其路徑。 如需詳細資訊，請參閱 Web 根目錄。\n防止在 wwwroot 中使用專案檔中的>來發佈檔案。 下列範例會防止在 wwwroot/local 及其子目錄中發佈內容：\n<ItemGroup>\n  <Content Update=\"wwwroot\\local\\**\\*.*\" CopyToPublishDirectory=\"Never\" />\n</ItemGroup>\n\n在 Razor.cshtml 檔案中，~/ 會指向 Web 根目錄。 開頭為 ~/ 的路徑稱為虛擬路徑。\n如需詳細資訊，請參閱 ASP.NET Core 中的靜態檔案。\n其他資源\n\n\n              WebApplicationBuilder 原始程式碼\n\n\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t您可以在 GitHub 上找到此內容的來源，在其中建立和檢閱問題和提取要求。 如需詳細資訊，請參閱我們的參與者指南。\n\t\t\t\t\n\t\t\t\n\n\t\t\t\t\t\t\n\t\n\n\t\n\n\t\n\n"
    },
    {
        "output": "URL: https://learn.microsoft.com/zh-tw/aspnet/core/fundamentals/middleware/extensibility-third-party-container\nTITLE: 在 ASP.NET Core 中以協力廠商容器啟用中介軟體\nCONTENT: \n\t\n\t\t跳到主要內容\n\n\t\t\n\t\t\t\t已不再支援此瀏覽器。\n\t\t\t\t請升級至 Microsoft Edge，以利用最新功能、安全性更新和技術支援。\n\t\t\t\t\n\t\t\t\n\t\t\n\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\n\n\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t在 ASP.NET Core 中以協力廠商容器啟用中介軟體\n\t\t\t\t\t\t\t\t\t\t\t發行項11/06/2024\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t本文內容\n\t\t\t\t\t\t\t\t\t\t\n注意\n這不是這篇文章的最新版本。 如需目前的版本，請參閱 本文的 .NET 9 版本。\n\n\n\n重要\n這些發行前產品的相關資訊在產品正式發行前可能會有大幅修改。 Microsoft 對此處提供的資訊，不做任何明確或隱含的瑕疵擔保。\n如需目前的版本，請參閱 本文的 .NET 9 版本。\n\n\n\n此文章示範如何使用 IMiddlewareFactory 與 IMiddleware 作為以協力廠商容器啟用中介軟體的擴充點。 如需 IMiddlewareFactory 和 IMiddleware 的簡介資訊，請參閱在 ASP.NET Core 中以 Factory 為基礎的中介軟體啟用。\n檢視或下載範例程式碼 \\(英文\\) (如何下載)\n範例應用程式會示範如何透過 IMiddlewareFactory 的實作 SimpleInjectorMiddlewareFactory 來啟用中介軟體。 此範例會使用 Simple Injector 相依性插入 (DI) 容器。\n範例的中介軟體實作會記錄查詢字串參數 (key) 所提供的值。 中介軟體會使用插入的資料庫內容 (範圍服務)，以記錄記憶體內部資料庫的查詢字串值。\n\nIMiddlewareFactory\nIMiddlewareFactory 提供建立中介軟體的方法。\n在範例應用程式中，將實作中介軟體 Factory 來建立 SimpleInjectorActivatedMiddleware 執行個體。 中介軟體 Factory 會使用 Simple Injector 容器來解析中介軟體：\npublic class SimpleInjectorMiddlewareFactory : IMiddlewareFactory\n{\n    private readonly Container _container;\n\n    public SimpleInjectorMiddlewareFactory(Container container)\n    {\n        _container = container;\n    }\n\n    public IMiddleware Create(Type middlewareType)\n    {\n        return _container.GetInstance(middlewareType) as IMiddleware;\n    }\n\n    public void Release(IMiddleware middleware)\n    {\n        // The container is responsible for releasing resources.\n    }\n}\nIMiddleware\nIMiddleware 可定義應用程式要求管線的中介軟體。\nIMiddlewareFactory 實作所啟動的中介軟體 (Middleware/SimpleInjectorActivatedMiddleware.cs)：\npublic class SimpleInjectorActivatedMiddleware : IMiddleware\n{\n    private readonly AppDbContext _db;\n\n    public SimpleInjectorActivatedMiddleware(AppDbContext db)\n    {\n        _db = db;\n    }\n\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next)\n    {\n        var keyValue = context.Request.Query[\"key\"];\n\n        if (!string.IsNullOrWhiteSpace(keyValue))\n        {\n            _db.Add(new Request()\n                {\n                    DT = DateTime.UtcNow, \n                    MiddlewareActivation = \"SimpleInjectorActivatedMiddleware\", \n                    Value = keyValue\n                });\n\n            await _db.SaveChangesAsync();\n        }\n\n        await next(context);\n    }\n}\n\n為中介軟體 (Middleware/MiddlewareExtensions.cs) 建立延伸模組：\npublic static class MiddlewareExtensions\n{\n    public static IApplicationBuilder UseSimpleInjectorActivatedMiddleware(\n        this IApplicationBuilder builder)\n    {\n        return builder.UseMiddleware<SimpleInjectorActivatedMiddleware>();\n    }\n}\n\nStartup.ConfigureServices 必須執行幾項工作：\n\n設定 Simple Injector 容器。\n註冊 Factory 和中介軟體。\n讓應用程式的資料庫內容可從 Simple Injector 容器使用。\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddRazorPages();\n\n    // Replace the default middleware factory with the \n    // SimpleInjectorMiddlewareFactory.\n    services.AddTransient<IMiddlewareFactory>(_ =>\n    {\n        return new SimpleInjectorMiddlewareFactory(_container);\n    });\n\n    // Wrap ASP.NET Core requests in a Simple Injector execution \n    // context.\n    services.UseSimpleInjectorAspNetRequestScoping(_container);\n\n    // Provide the database context from the Simple \n    // Injector container whenever it's requested from \n    // the default service container.\n    services.AddScoped<AppDbContext>(provider => \n        _container.GetInstance<AppDbContext>());\n\n    _container.Options.DefaultScopedLifestyle = new AsyncScopedLifestyle();\n\n    _container.Register<AppDbContext>(() => \n    {\n        var optionsBuilder = new DbContextOptionsBuilder<DbContext>();\n        optionsBuilder.UseInMemoryDatabase(\"InMemoryDb\");\n        return new AppDbContext(optionsBuilder.Options);\n    }, Lifestyle.Scoped);\n\n    _container.Register<SimpleInjectorActivatedMiddleware>();\n\n    _container.Verify();\n}\n\n此中介軟體會在要求處理管線的 Startup.Configure 中註冊：\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        app.UseExceptionHandler(\"/Error\");\n    }\n\n    app.UseSimpleInjectorActivatedMiddleware();\n\n    app.UseStaticFiles();\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapRazorPages();\n    });\n}\n\n\n此文章示範如何使用 IMiddlewareFactory 與 IMiddleware 作為以協力廠商容器啟用中介軟體的擴充點。 如需 IMiddlewareFactory 和 IMiddleware 的簡介資訊，請參閱在 ASP.NET Core 中以 Factory 為基礎的中介軟體啟用。\n檢視或下載範例程式碼 \\(英文\\) (如何下載)\n範例應用程式會示範如何透過 IMiddlewareFactory 的實作 SimpleInjectorMiddlewareFactory 來啟用中介軟體。 此範例會使用 Simple Injector 相依性插入 (DI) 容器。\n範例的中介軟體實作會記錄查詢字串參數 (key) 所提供的值。 中介軟體會使用插入的資料庫內容 (範圍服務)，以記錄記憶體內部資料庫的查詢字串值。\n\nIMiddlewareFactory\nIMiddlewareFactory 提供建立中介軟體的方法。\n在範例應用程式中，將實作中介軟體 Factory 來建立 SimpleInjectorActivatedMiddleware 執行個體。 中介軟體 Factory 會使用 Simple Injector 容器來解析中介軟體：\npublic class SimpleInjectorMiddlewareFactory : IMiddlewareFactory\n{\n    private readonly Container _container;\n\n    public SimpleInjectorMiddlewareFactory(Container container)\n    {\n        _container = container;\n    }\n\n    public IMiddleware Create(Type middlewareType)\n    {\n        return _container.GetInstance(middlewareType) as IMiddleware;\n    }\n\n    public void Release(IMiddleware middleware)\n    {\n        // The container is responsible for releasing resources.\n    }\n}\nIMiddleware\nIMiddleware 可定義應用程式要求管線的中介軟體。\nIMiddlewareFactory 實作所啟動的中介軟體 (Middleware/SimpleInjectorActivatedMiddleware.cs)：\npublic class SimpleInjectorActivatedMiddleware : IMiddleware\n{\n    private readonly AppDbContext _db;\n\n    public SimpleInjectorActivatedMiddleware(AppDbContext db)\n    {\n        _db = db;\n    }\n\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next)\n    {\n        var keyValue = context.Request.Query[\"key\"];\n\n        if (!string.IsNullOrWhiteSpace(keyValue))\n        {\n            _db.Add(new Request()\n                {\n                    DT = DateTime.UtcNow, \n                    MiddlewareActivation = \"SimpleInjectorActivatedMiddleware\", \n                    Value = keyValue\n                });\n\n            await _db.SaveChangesAsync();\n        }\n\n        await next(context);\n    }\n}\n\n為中介軟體 (Middleware/MiddlewareExtensions.cs) 建立延伸模組：\npublic static class MiddlewareExtensions\n{\n    public static IApplicationBuilder UseSimpleInjectorActivatedMiddleware(\n        this IApplicationBuilder builder)\n    {\n        return builder.UseMiddleware<SimpleInjectorActivatedMiddleware>();\n    }\n}\n\nStartup.ConfigureServices 必須執行幾項工作：\n\n設定 Simple Injector 容器。\n註冊 Factory 和中介軟體。\n讓應用程式的資料庫內容可從 Simple Injector 容器使用。\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\n    // Replace the default middleware factory with the \n    // SimpleInjectorMiddlewareFactory.\n    services.AddTransient<IMiddlewareFactory>(_ =>\n    {\n        return new SimpleInjectorMiddlewareFactory(_container);\n    });\n\n    // Wrap ASP.NET Core requests in a Simple Injector execution \n    // context.\n    services.UseSimpleInjectorAspNetRequestScoping(_container);\n\n    // Provide the database context from the Simple \n    // Injector container whenever it's requested from \n    // the default service container.\n    services.AddScoped<AppDbContext>(provider => \n        _container.GetInstance<AppDbContext>());\n\n    _container.Options.DefaultScopedLifestyle = new AsyncScopedLifestyle();\n\n    _container.Register<AppDbContext>(() => \n    {\n        var optionsBuilder = new DbContextOptionsBuilder<DbContext>();\n        optionsBuilder.UseInMemoryDatabase(\"InMemoryDb\");\n        return new AppDbContext(optionsBuilder.Options);\n    }, Lifestyle.Scoped);\n\n    _container.Register<SimpleInjectorActivatedMiddleware>();\n\n    _container.Verify();\n}\n\n此中介軟體會在要求處理管線的 Startup.Configure 中註冊：\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        app.UseExceptionHandler(\"/Error\");\n    }\n\n    app.UseSimpleInjectorActivatedMiddleware();\n\n    app.UseStaticFiles();\n    app.UseMvc();\n}\n\n其他資源\n\n中介軟體\nFactory 式中介軟體啟用\nSimple Injector GitHub repository (Simple Injector GitHub 存放庫)\nSimple Injector documentation (Simple Injector 文件)\n\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t您可以在 GitHub 上找到此內容的來源，在其中建立和檢閱問題和提取要求。 如需詳細資訊，請參閱我們的參與者指南。\n\t\t\t\t\n\t\t\t\n\n\t\t\t\t\t\t\n\t\n\n\t\n\n\t\n\n"
    },
    {
        "output": "URL: https://learn.microsoft.com/zh-tw/aspnet/core/mvc/controllers/dependency-injection\nTITLE: ASP.NET Core 控制器的相依性插入\nCONTENT: \n\t\n\t\t跳到主要內容\n\n\t\t\n\t\t\t\t已不再支援此瀏覽器。\n\t\t\t\t請升級至 Microsoft Edge，以利用最新功能、安全性更新和技術支援。\n\t\t\t\t\n\t\t\t\n\t\t\n\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\n\n\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tASP.NET Core 控制器的相依性插入\n\t\t\t\t\t\t\t\t\t\t\t發行項11/06/2024\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t本文內容\n\t\t\t\t\t\t\t\t\t\t\n作者：Shadi Alnamrouti 和 Rick Anderson\n\nASP.NET Core MVC 控制器會透過建構函式明確地要求相依性。 ASP.NET Core 內建相依性插入 (DI) 支援。 DI 可讓您更輕鬆地測試和維護應用程式。\n檢視或下載範例程式碼 \\(英文\\) (如何下載)\n建構函式插入\n服務會新增來作為建構函式參數，而執行階段會解析來自服務容器的服務。 通常可以使用介面來定義服務。 例如，假設應用程式需要目前的時間。 下列介面會公開 IDateTime 服務：\npublic interface IDateTime\n{\n    DateTime Now { get; }\n}\n\n下列程式碼會實作 IDateTime 介面：\npublic class SystemDateTime : IDateTime\n{\n    public DateTime Now\n    {\n        get { return DateTime.Now; }\n    }\n}\n\n將服務新增至服務容器：\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton<IDateTime, SystemDateTime>();\n\n    services.AddControllersWithViews();\n}\n\n如需 AddSingleton 的詳細資訊，請參閱 DI 服務存留期。\n下列程式碼會根據時段來向使用者顯示問候語：\npublic class HomeController : Controller\n{\n    private readonly IDateTime _dateTime;\n\n    public HomeController(IDateTime dateTime)\n    {\n        _dateTime = dateTime;\n    }\n\n    public IActionResult Index()\n    {\n        var serverTime = _dateTime.Now;\n        if (serverTime.Hour < 12)\n        {\n            ViewData[\"Message\"] = \"It's morning here - Good Morning!\";\n        }\n        else if (serverTime.Hour < 17)\n        {\n            ViewData[\"Message\"] = \"It's afternoon here - Good Afternoon!\";\n        }\n        else\n        {\n            ViewData[\"Message\"] = \"It's evening here - Good Evening!\";\n        }\n        return View();\n    }\n\n執行應用程式，並根據時間顯示訊息。\n使用 FromServices 進行動作插入\nFromServicesAttribute 能夠將服務直接插入至動作方法，而不需使用建構函式插入：\npublic IActionResult About([FromServices] IDateTime dateTime)\n{\n    return Content( $\"Current server time: {dateTime.Now}\");\n}\n使用 FromKeyedServices 進行動作插入\n下列程式碼示範如何使用 [FromKeyedServices] 屬性來從 DI 容器存取具有索引鍵的服務：\nusing Microsoft.AspNetCore.Mvc;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddKeyedSingleton<ICache, BigCache>(\"big\");\nbuilder.Services.AddKeyedSingleton<ICache, SmallCache>(\"small\");\nbuilder.Services.AddControllers();\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n\npublic interface ICache\n{\n    object Get(string key);\n}\npublic class BigCache : ICache\n{\n    public object Get(string key) => $\"Resolving {key} from big cache.\";\n}\n\npublic class SmallCache : ICache\n{\n    public object Get(string key) => $\"Resolving {key} from small cache.\";\n}\n\n[ApiController]\n[Route(\"/cache\")]\npublic class CustomServicesApiController : Controller\n{\n    [HttpGet(\"big\")]\n    public ActionResult<object> GetBigCache([FromKeyedServices(\"big\")] ICache cache)\n    {\n        return cache.Get(\"data-mvc\");\n    }\n\n    [HttpGet(\"small\")]\n    public ActionResult<object> GetSmallCache([FromKeyedServices(\"small\")] ICache cache)\n    {\n        return cache.Get(\"data-mvc\");\n    }\n}\n\n從控制器存取設定\n從控制器存取應用程式或組態設定是常見的模式。 ASP.NET Core 中的 [選項] 模式中所述的選項模式是管理設定的慣用方法。 一般而言，不要將 IConfiguration 直接插入至控制器。\n建立要代表選項的類別。 例如：\npublic class SampleWebSettings\n{\n    public string Title { get; set; }\n    public int Updates { get; set; }\n}\n\n將設定類別新增至服務集合：\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton<IDateTime, SystemDateTime>();\n    services.Configure<SampleWebSettings>(Configuration);\n\n    services.AddControllersWithViews();\n}\n\n設定應用程式以從 JSON 格式的檔案中讀取設定：\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        CreateHostBuilder(args).Build().Run();\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureAppConfiguration((hostingContext, config) =>\n            {\n                config.AddJsonFile(\"samplewebsettings.json\",\n                    optional: false,\n                    reloadOnChange: true);\n            })\n            .ConfigureWebHostDefaults(webBuilder =>\n            {\n                webBuilder.UseStartup<Startup>();\n            });\n}\n\n下列程式碼會向服務容器要求 IOptions<SampleWebSettings> 設定，並在 Index 方法中使用它們：\npublic class SettingsController : Controller\n{\n    private readonly SampleWebSettings _settings;\n\n    public SettingsController(IOptions<SampleWebSettings> settingsOptions)\n    {\n        _settings = settingsOptions.Value;\n    }\n\n    public IActionResult Index()\n    {\n        ViewData[\"Title\"] = _settings.Title;\n        ViewData[\"Updates\"] = _settings.Updates;\n        return View();\n    }\n}\n其他資源\n\n請參閱測試 ASP.NET Core 中的控制器邏輯以了解如何透過明確地要求控制器中的相依性，以讓程式碼更容易測試。\n具有索引鍵的服務相依性插入容器支援\n使用協力廠商實作來取代預設的相依性插入容器。\n\n\n\n作者：Shadi Alnamrouti、Rick Anderson 和 Steve Smith\nASP.NET Core MVC 控制器會透過建構函式明確地要求相依性。 ASP.NET Core 內建相依性插入 (DI) 支援。 DI 可讓您更輕鬆地測試和維護應用程式。\n檢視或下載範例程式碼 \\(英文\\) (如何下載)\n建構函式插入\n服務會新增來作為建構函式參數，而執行階段會解析來自服務容器的服務。 通常可以使用介面來定義服務。 例如，假設應用程式需要目前的時間。 下列介面會公開 IDateTime 服務：\npublic interface IDateTime\n{\n    DateTime Now { get; }\n}\n\n下列程式碼會實作 IDateTime 介面：\npublic class SystemDateTime : IDateTime\n{\n    public DateTime Now\n    {\n        get { return DateTime.Now; }\n    }\n}\n\n將服務新增至服務容器：\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton<IDateTime, SystemDateTime>();\n\n    services.AddControllersWithViews();\n}\n\n如需 AddSingleton 的詳細資訊，請參閱 DI 服務存留期。\n下列程式碼會根據時段來向使用者顯示問候語：\npublic class HomeController : Controller\n{\n    private readonly IDateTime _dateTime;\n\n    public HomeController(IDateTime dateTime)\n    {\n        _dateTime = dateTime;\n    }\n\n    public IActionResult Index()\n    {\n        var serverTime = _dateTime.Now;\n        if (serverTime.Hour < 12)\n        {\n            ViewData[\"Message\"] = \"It's morning here - Good Morning!\";\n        }\n        else if (serverTime.Hour < 17)\n        {\n            ViewData[\"Message\"] = \"It's afternoon here - Good Afternoon!\";\n        }\n        else\n        {\n            ViewData[\"Message\"] = \"It's evening here - Good Evening!\";\n        }\n        return View();\n    }\n\n執行應用程式，並根據時間顯示訊息。\n使用 FromServices 進行動作插入\nFromServicesAttribute 能夠將服務直接插入至動作方法，而不需使用建構函式插入：\npublic IActionResult About([FromServices] IDateTime dateTime)\n{\n    return Content( $\"Current server time: {dateTime.Now}\");\n}\n從控制器存取設定\n從控制器存取應用程式或組態設定是常見的模式。 ASP.NET Core 中的 [選項] 模式中所述的選項模式是管理設定的慣用方法。 一般而言，不要將 IConfiguration 直接插入至控制器。\n建立要代表選項的類別。 例如：\npublic class SampleWebSettings\n{\n    public string Title { get; set; }\n    public int Updates { get; set; }\n}\n\n將設定類別新增至服務集合：\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton<IDateTime, SystemDateTime>();\n    services.Configure<SampleWebSettings>(Configuration);\n\n    services.AddControllersWithViews();\n}\n\n設定應用程式以從 JSON 格式的檔案中讀取設定：\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        CreateHostBuilder(args).Build().Run();\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureAppConfiguration((hostingContext, config) =>\n            {\n                config.AddJsonFile(\"samplewebsettings.json\",\n                    optional: false,\n                    reloadOnChange: true);\n            })\n            .ConfigureWebHostDefaults(webBuilder =>\n            {\n                webBuilder.UseStartup<Startup>();\n            });\n}\n\n下列程式碼會向服務容器要求 IOptions<SampleWebSettings> 設定，並在 Index 方法中使用它們：\npublic class SettingsController : Controller\n{\n    private readonly SampleWebSettings _settings;\n\n    public SettingsController(IOptions<SampleWebSettings> settingsOptions)\n    {\n        _settings = settingsOptions.Value;\n    }\n\n    public IActionResult Index()\n    {\n        ViewData[\"Title\"] = _settings.Title;\n        ViewData[\"Updates\"] = _settings.Updates;\n        return View();\n    }\n}\n其他資源\n\n請參閱測試 ASP.NET Core 中的控制器邏輯以了解如何透過明確地要求控制器中的相依性，以讓程式碼更容易測試。\n\n使用協力廠商實作來取代預設的相依性插入容器。\n\n\n\n\n作者：Shadi Namrouti、Rick Anderson 和 Steve Smith\nASP.NET Core MVC 控制器會透過建構函式明確地要求相依性。 ASP.NET Core 內建相依性插入 (DI) 支援。 DI 可讓您更輕鬆地測試和維護應用程式。\n檢視或下載範例程式碼 \\(英文\\) (如何下載)\n建構函式插入\n服務會新增來作為建構函式參數，而執行階段會解析來自服務容器的服務。 通常可以使用介面來定義服務。 例如，假設應用程式需要目前的時間。 下列介面會公開 IDateTime 服務：\npublic interface IDateTime\n{\n    DateTime Now { get; }\n}\n\n下列程式碼會實作 IDateTime 介面：\npublic class SystemDateTime : IDateTime\n{\n    public DateTime Now\n    {\n        get { return DateTime.Now; }\n    }\n}\n\n將服務新增至服務容器：\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton<IDateTime, SystemDateTime>();\n\n    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n}\n\n如需 AddSingleton 的詳細資訊，請參閱 DI 服務存留期。\n下列程式碼會根據時段來向使用者顯示問候語：\npublic class HomeController : Controller\n{\n    private readonly IDateTime _dateTime;\n\n    public HomeController(IDateTime dateTime)\n    {\n        _dateTime = dateTime;\n    }\n\n    public IActionResult Index()\n    {\n        var serverTime = _dateTime.Now;\n        if (serverTime.Hour < 12)\n        {\n            ViewData[\"Message\"] = \"It's morning here - Good Morning!\";\n        }\n        else if (serverTime.Hour < 17)\n        {\n            ViewData[\"Message\"] = \"It's afternoon here - Good Afternoon!\";\n        }\n        else\n        {\n            ViewData[\"Message\"] = \"It's evening here - Good Evening!\";\n        }\n        return View();\n    }\n\n執行應用程式，並根據時間顯示訊息。\n使用 FromServices 進行動作插入\nFromServicesAttribute 能夠將服務直接插入至動作方法，而不需使用建構函式插入：\npublic IActionResult About([FromServices] IDateTime dateTime)\n{\n    ViewData[\"Message\"] = $\"Current server time: {dateTime.Now}\";\n\n    return View();\n}\n從控制器存取設定\n從控制器存取應用程式或組態設定是常見的模式。 ASP.NET Core 中的 [選項] 模式中所述的選項模式是管理設定的慣用方法。 一般而言，不要將 IConfiguration 直接插入至控制器。\n建立要代表選項的類別。 例如：\npublic class SampleWebSettings\n{\n    public string Title { get; set; }\n    public int Updates { get; set; }\n}\n\n將設定類別新增至服務集合：\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton<IDateTime, SystemDateTime>();\n    services.Configure<SampleWebSettings>(Configuration);\n    \n    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n}\n\n設定應用程式以從 JSON 格式的檔案中讀取設定：\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        CreateWebHostBuilder(args).Build().Run();\n    }\n\n    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>\n        WebHost.CreateDefaultBuilder(args)\n        .ConfigureAppConfiguration((hostingContext, config) =>\n        {\n            config.AddJsonFile(\"samplewebsettings.json\", \n                                optional: false,        // File is not optional.\n                                reloadOnChange: false);\n        })\n        .UseStartup<Startup>();\n}\n\n下列程式碼會向服務容器要求 IOptions<SampleWebSettings> 設定，並在 Index 方法中使用它們：\npublic class SettingsController : Controller\n{\n    private readonly SampleWebSettings _settings;\n\n    public SettingsController(IOptions<SampleWebSettings> settingsOptions)\n    {\n        _settings = settingsOptions.Value;\n    }\n\n    public IActionResult Index()\n    {\n        ViewData[\"Title\"] = _settings.Title;\n        ViewData[\"Updates\"] = _settings.Updates;\n        return View();\n    }\n}\n其他資源\n\n請參閱測試 ASP.NET Core 中的控制器邏輯以了解如何透過明確地要求控制器中的相依性，以讓程式碼更容易測試。\n\n使用協力廠商實作來取代預設的相依性插入容器。\n\n\n\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t您可以在 GitHub 上找到此內容的來源，在其中建立和檢閱問題和提取要求。 如需詳細資訊，請參閱我們的參與者指南。\n\t\t\t\t\n\t\t\t\n\n\t\t\t\t\t\t\n\t\n\n\t\n\n\t\n\n"
    },
    {
        "output": "URL: https://learn.microsoft.com/zh-tw/aspnet/core/fundamentals/middleware/extensibility-third-party-container\nTITLE: 在 ASP.NET Core 中以協力廠商容器啟用中介軟體\nCONTENT: \n\t\n\t\t跳到主要內容\n\n\t\t\n\t\t\t\t已不再支援此瀏覽器。\n\t\t\t\t請升級至 Microsoft Edge，以利用最新功能、安全性更新和技術支援。\n\t\t\t\t\n\t\t\t\n\t\t\n\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\n\n\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t在 ASP.NET Core 中以協力廠商容器啟用中介軟體\n\t\t\t\t\t\t\t\t\t\t\t發行項11/06/2024\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t本文內容\n\t\t\t\t\t\t\t\t\t\t\n注意\n這不是這篇文章的最新版本。 如需目前的版本，請參閱 本文的 .NET 9 版本。\n\n\n\n重要\n這些發行前產品的相關資訊在產品正式發行前可能會有大幅修改。 Microsoft 對此處提供的資訊，不做任何明確或隱含的瑕疵擔保。\n如需目前的版本，請參閱 本文的 .NET 9 版本。\n\n\n\n此文章示範如何使用 IMiddlewareFactory 與 IMiddleware 作為以協力廠商容器啟用中介軟體的擴充點。 如需 IMiddlewareFactory 和 IMiddleware 的簡介資訊，請參閱在 ASP.NET Core 中以 Factory 為基礎的中介軟體啟用。\n檢視或下載範例程式碼 \\(英文\\) (如何下載)\n範例應用程式會示範如何透過 IMiddlewareFactory 的實作 SimpleInjectorMiddlewareFactory 來啟用中介軟體。 此範例會使用 Simple Injector 相依性插入 (DI) 容器。\n範例的中介軟體實作會記錄查詢字串參數 (key) 所提供的值。 中介軟體會使用插入的資料庫內容 (範圍服務)，以記錄記憶體內部資料庫的查詢字串值。\n\nIMiddlewareFactory\nIMiddlewareFactory 提供建立中介軟體的方法。\n在範例應用程式中，將實作中介軟體 Factory 來建立 SimpleInjectorActivatedMiddleware 執行個體。 中介軟體 Factory 會使用 Simple Injector 容器來解析中介軟體：\npublic class SimpleInjectorMiddlewareFactory : IMiddlewareFactory\n{\n    private readonly Container _container;\n\n    public SimpleInjectorMiddlewareFactory(Container container)\n    {\n        _container = container;\n    }\n\n    public IMiddleware Create(Type middlewareType)\n    {\n        return _container.GetInstance(middlewareType) as IMiddleware;\n    }\n\n    public void Release(IMiddleware middleware)\n    {\n        // The container is responsible for releasing resources.\n    }\n}\nIMiddleware\nIMiddleware 可定義應用程式要求管線的中介軟體。\nIMiddlewareFactory 實作所啟動的中介軟體 (Middleware/SimpleInjectorActivatedMiddleware.cs)：\npublic class SimpleInjectorActivatedMiddleware : IMiddleware\n{\n    private readonly AppDbContext _db;\n\n    public SimpleInjectorActivatedMiddleware(AppDbContext db)\n    {\n        _db = db;\n    }\n\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next)\n    {\n        var keyValue = context.Request.Query[\"key\"];\n\n        if (!string.IsNullOrWhiteSpace(keyValue))\n        {\n            _db.Add(new Request()\n                {\n                    DT = DateTime.UtcNow, \n                    MiddlewareActivation = \"SimpleInjectorActivatedMiddleware\", \n                    Value = keyValue\n                });\n\n            await _db.SaveChangesAsync();\n        }\n\n        await next(context);\n    }\n}\n\n為中介軟體 (Middleware/MiddlewareExtensions.cs) 建立延伸模組：\npublic static class MiddlewareExtensions\n{\n    public static IApplicationBuilder UseSimpleInjectorActivatedMiddleware(\n        this IApplicationBuilder builder)\n    {\n        return builder.UseMiddleware<SimpleInjectorActivatedMiddleware>();\n    }\n}\n\nStartup.ConfigureServices 必須執行幾項工作：\n\n設定 Simple Injector 容器。\n註冊 Factory 和中介軟體。\n讓應用程式的資料庫內容可從 Simple Injector 容器使用。\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddRazorPages();\n\n    // Replace the default middleware factory with the \n    // SimpleInjectorMiddlewareFactory.\n    services.AddTransient<IMiddlewareFactory>(_ =>\n    {\n        return new SimpleInjectorMiddlewareFactory(_container);\n    });\n\n    // Wrap ASP.NET Core requests in a Simple Injector execution \n    // context.\n    services.UseSimpleInjectorAspNetRequestScoping(_container);\n\n    // Provide the database context from the Simple \n    // Injector container whenever it's requested from \n    // the default service container.\n    services.AddScoped<AppDbContext>(provider => \n        _container.GetInstance<AppDbContext>());\n\n    _container.Options.DefaultScopedLifestyle = new AsyncScopedLifestyle();\n\n    _container.Register<AppDbContext>(() => \n    {\n        var optionsBuilder = new DbContextOptionsBuilder<DbContext>();\n        optionsBuilder.UseInMemoryDatabase(\"InMemoryDb\");\n        return new AppDbContext(optionsBuilder.Options);\n    }, Lifestyle.Scoped);\n\n    _container.Register<SimpleInjectorActivatedMiddleware>();\n\n    _container.Verify();\n}\n\n此中介軟體會在要求處理管線的 Startup.Configure 中註冊：\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        app.UseExceptionHandler(\"/Error\");\n    }\n\n    app.UseSimpleInjectorActivatedMiddleware();\n\n    app.UseStaticFiles();\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapRazorPages();\n    });\n}\n\n\n此文章示範如何使用 IMiddlewareFactory 與 IMiddleware 作為以協力廠商容器啟用中介軟體的擴充點。 如需 IMiddlewareFactory 和 IMiddleware 的簡介資訊，請參閱在 ASP.NET Core 中以 Factory 為基礎的中介軟體啟用。\n檢視或下載範例程式碼 \\(英文\\) (如何下載)\n範例應用程式會示範如何透過 IMiddlewareFactory 的實作 SimpleInjectorMiddlewareFactory 來啟用中介軟體。 此範例會使用 Simple Injector 相依性插入 (DI) 容器。\n範例的中介軟體實作會記錄查詢字串參數 (key) 所提供的值。 中介軟體會使用插入的資料庫內容 (範圍服務)，以記錄記憶體內部資料庫的查詢字串值。\n\nIMiddlewareFactory\nIMiddlewareFactory 提供建立中介軟體的方法。\n在範例應用程式中，將實作中介軟體 Factory 來建立 SimpleInjectorActivatedMiddleware 執行個體。 中介軟體 Factory 會使用 Simple Injector 容器來解析中介軟體：\npublic class SimpleInjectorMiddlewareFactory : IMiddlewareFactory\n{\n    private readonly Container _container;\n\n    public SimpleInjectorMiddlewareFactory(Container container)\n    {\n        _container = container;\n    }\n\n    public IMiddleware Create(Type middlewareType)\n    {\n        return _container.GetInstance(middlewareType) as IMiddleware;\n    }\n\n    public void Release(IMiddleware middleware)\n    {\n        // The container is responsible for releasing resources.\n    }\n}\nIMiddleware\nIMiddleware 可定義應用程式要求管線的中介軟體。\nIMiddlewareFactory 實作所啟動的中介軟體 (Middleware/SimpleInjectorActivatedMiddleware.cs)：\npublic class SimpleInjectorActivatedMiddleware : IMiddleware\n{\n    private readonly AppDbContext _db;\n\n    public SimpleInjectorActivatedMiddleware(AppDbContext db)\n    {\n        _db = db;\n    }\n\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next)\n    {\n        var keyValue = context.Request.Query[\"key\"];\n\n        if (!string.IsNullOrWhiteSpace(keyValue))\n        {\n            _db.Add(new Request()\n                {\n                    DT = DateTime.UtcNow, \n                    MiddlewareActivation = \"SimpleInjectorActivatedMiddleware\", \n                    Value = keyValue\n                });\n\n            await _db.SaveChangesAsync();\n        }\n\n        await next(context);\n    }\n}\n\n為中介軟體 (Middleware/MiddlewareExtensions.cs) 建立延伸模組：\npublic static class MiddlewareExtensions\n{\n    public static IApplicationBuilder UseSimpleInjectorActivatedMiddleware(\n        this IApplicationBuilder builder)\n    {\n        return builder.UseMiddleware<SimpleInjectorActivatedMiddleware>();\n    }\n}\n\nStartup.ConfigureServices 必須執行幾項工作：\n\n設定 Simple Injector 容器。\n註冊 Factory 和中介軟體。\n讓應用程式的資料庫內容可從 Simple Injector 容器使用。\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\n    // Replace the default middleware factory with the \n    // SimpleInjectorMiddlewareFactory.\n    services.AddTransient<IMiddlewareFactory>(_ =>\n    {\n        return new SimpleInjectorMiddlewareFactory(_container);\n    });\n\n    // Wrap ASP.NET Core requests in a Simple Injector execution \n    // context.\n    services.UseSimpleInjectorAspNetRequestScoping(_container);\n\n    // Provide the database context from the Simple \n    // Injector container whenever it's requested from \n    // the default service container.\n    services.AddScoped<AppDbContext>(provider => \n        _container.GetInstance<AppDbContext>());\n\n    _container.Options.DefaultScopedLifestyle = new AsyncScopedLifestyle();\n\n    _container.Register<AppDbContext>(() => \n    {\n        var optionsBuilder = new DbContextOptionsBuilder<DbContext>();\n        optionsBuilder.UseInMemoryDatabase(\"InMemoryDb\");\n        return new AppDbContext(optionsBuilder.Options);\n    }, Lifestyle.Scoped);\n\n    _container.Register<SimpleInjectorActivatedMiddleware>();\n\n    _container.Verify();\n}\n\n此中介軟體會在要求處理管線的 Startup.Configure 中註冊：\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        app.UseExceptionHandler(\"/Error\");\n    }\n\n    app.UseSimpleInjectorActivatedMiddleware();\n\n    app.UseStaticFiles();\n    app.UseMvc();\n}\n\n其他資源\n\n中介軟體\nFactory 式中介軟體啟用\nSimple Injector GitHub repository (Simple Injector GitHub 存放庫)\nSimple Injector documentation (Simple Injector 文件)\n\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t您可以在 GitHub 上找到此內容的來源，在其中建立和檢閱問題和提取要求。 如需詳細資訊，請參閱我們的參與者指南。\n\t\t\t\t\n\t\t\t\n\n\t\t\t\t\t\t\n\t\n\n\t\n\n\t\n\n"
    },
    {
        "output": "URL: https://learn.microsoft.com/zh-tw/dotnet/core/dependency-loading/overview\nTITLE: 相依性載入 - .NET\nCONTENT: \n\t\n\t\t跳到主要內容\n\n\t\t\n\t\t\t\t已不再支援此瀏覽器。\n\t\t\t\t請升級至 Microsoft Edge，以利用最新功能、安全性更新和技術支援。\n\t\t\t\t\n\t\t\t\t\t下載 Microsoft Edge\n\t\t\t\t\tInternet Explorer 和 Microsoft Edge 的詳細資訊\n\t\t\t\t\n\t\t\t\n\t\t\n\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\n\n\t\n\t\t\t\t\n\t\t\t\n\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t閱讀英文\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t閱讀英文\n\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\t\t \t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t共用方式為\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t.NET 中的相依性載入\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t發行項02/26/2024\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\t\t本文內容\n\t\t\t\t\t\t\t\t\t\t每個 .NET 應用程式都有相依性。 就連單純的 hello world 應用程式也對部分 .NET 類別程式庫具有相依性。\n了解 .NET 中的預設組件載入邏輯，能幫助您為一般部署問題疑難排解。\n在部分應用程式中，相依性會於執行階段動態判定。 在這些情況中，了解受控組件與非受控相依性的載入方式很重要。\nAssemblyLoadContext\nAssemblyLoadContext API 是 .NET 載入設計的核心。 了解 AssemblyLoadContext 一文提供該項設計概念方面的概觀。\n載入詳細資料\n載入演算法的詳細資料，略述於幾篇文章中：\n\n受控組件載入演算法\n附屬組件載入演算法\n非受控 (原生) 程式庫載入演算法\n預設探查\n\n使用外掛程式建立應用程式\n用外掛程式建立 .NET 應用程式 教學課程說明如何建立自訂 AssemblyLoadContext。 其中使用 AssemblyDependencyResolver 來解析外掛程式中的相依性。 該教學課程正確地將外掛程式的相依性從裝載應用程式中隔離出來。\n組件卸載功能\n如何在 .NET 中使用並偵錯組件卸載功能一文為逐步教學課程。 其中示範如何載入 .NET 應用程式，然後執行並卸載之。 該篇文章也提供偵錯祕訣。\n收集詳盡的組件載入資訊\n收集詳盡的組件載入資訊 一文說明如何在執行階段收集受控組件載入的詳盡資訊。 其中使用 dotnet-trace 工具來擷取執行流程追蹤中的組件載入器事件。\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t在 GitHub 上與我們共同作業\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t您可以在 GitHub 上找到此內容的來源，在其中建立和檢閱問題和提取要求。 如需詳細資訊，請參閱我們的參與者指南。\n\t\t\t\t\n\t\t\t\n\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t.NET\n\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t開啟文件問題\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t提供產品意見反應\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t其他資源\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t本文內容\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\n\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\n\n\t\n\n\t\n\n"
    }
    ]
---

system:
### Role Description:

You are a C# software development partner, specializing in assisting professional developers with any questions, suggestions, or clarifications related to C#. Your interaction style is relaxed and friendly, like chatting between developer friends. Keep responses concise and direct, providing explanations only when requested.

### Interaction Structure:

1. **Greet and Connect:** Start with a friendly greeting to set a relaxed atmosphere.
2. **Prompt Specific Query:** Ask for specific details about the C# issue or topic they need help with.
3. **Provide Direct Assistance:** Respond concisely to queries; avoid lengthy explanations unless specifically asked.
4. **Offer Further Help:** After providing assistance, ask if there's anything else related to C# they need help with.
5. **End Interaction:** Conclude the conversation with a friendly closing remark, encouraging them to reach out anytime they need further assistance.
6. **Language**: Respond in the same language as the user. BUT when the user uses 中文: (Respond in 正體中文zh-tw not 簡體中文zh-cn. Use full-width punctuation marks and always add a space between Chinese characters and alphanumeric characters. 專有名詞使用台灣正體中文常用術語。) Default to English if unclear. 

### AI Operation Guide:

- **Quick Response:** Aim for quick and straightforward answers to mimic real-time chat between friends.
- **Casual Language Use:** Maintain an informal and approachable tone throughout the interaction.
- **Provide Reference Links:** Always provide users with reference links when using Reference knowledge. Note: The link must genuinely exist in the referenced material; do not fabricate a link.
- **Wait for Prompting:** Do not elaborate on topics unless users request more detailed information.
- **Feedback Mechanism**: Encourage users to provide feedback on the solutions or information provided.

### Sample Prompt:

Hey! What C# challenge are you tackling today? 

### Additional Prompt:

Got it! Need help with anything else related to C#? Or do you have something else on your mind?

### Closing Prompt:

Great! If you need more C# help feel free to reach out anytime. Happy Coding! 👋


### Reference knowledge

Please refer to the following information to answer.

{{knowledge}}

\---
ALWAYS PROVIDE USERS WITH REFERENCE LINKS IF THEY ARE RELATED TO THE USER'S QUESTION OR WERE USED IN YOUR RESPONSE.
ALWAYS PROVIDE USERS WITH REFERENCE LINKS IF THEY ARE RELATED TO THE USER'S QUESTION OR WERE USED IN YOUR RESPONSE.
ALWAYS PROVIDE USERS WITH REFERENCE LINKS IF THEY ARE RELATED TO THE USER'S QUESTION OR WERE USED IN YOUR RESPONSE.

assistant:
🤖 遇見你的最佳 C# 助手 — C# AI Buddy！
💻 我能夠即時解答你的 C# 相關問題，提供程式碼優化建議，並協助你快速掌握這門強大的程式語言。
🚀 無論你是初學者還是經驗豐富的開發者，C# AI Buddy 都將成為你 Coding 之旅中不可或缺的得力助手！

user:
{{BOT_USER_INPUT}}
