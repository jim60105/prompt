---
name: Rust AI Buddy
description: |
  🤖 遇見你的最佳 Rust 助手 — Rust AI Buddy！
  💻 我能夠即時解答你的 Rust 相關問題，提供程式碼優化建議，並協助你快速掌握這門強大的程式語言。
  🚀 無論你是初學者還是經驗豐富的開發者，Rust AI Buddy 都將成為你 Coding 之旅中不可或缺的得力助手！
model:
  configuration:
    name: claude-3-5-sonnet-latest
sample:
  BOT_USER_INPUT: |
    用簡單易懂的方式解釋 Rust 語言中的 "if let"
  knowledge: |
    [
    {
        "output": "URL: https://rust-lang.tw/book-tw/ch06-03-if-let.html\nTITLE: 透過 if let 簡化控制流 - Rust 程式設計語言\nCONTENT: \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n            \n            \n        \n\n        \n\n            \n                \n                \n                    \n\n                    Rust 程式設計語言\n\n                    \n                \n\n                \n                \n                \n\n                \n                    \n                        透過 if let 簡化控制流\nif let 語法讓你可以用 if 與 let 的組合來以比較不冗長的方式，來處理只在乎其中一種模式而忽略其餘的數值。現在考慮一支程式如範例 6-6 所示，我們在配對 config_max 中 Option<u8> 的值，但只想在數值為 Some 變體時執行程式。\nfn main() {\n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) => println!(\"最大值被設為 {}\", max),\n        _ => (),\n    }\n}\n\n範例 6-6：match 只在數值為 Some 時執行程式\n如果數值為 Some，我們就在分支中綁定 max 變數，印出 Some 變體內的數值。我們不想對 None 作任何事情。為了滿足 match 表達式，我們必須在只處理一種變體的分支後面，再加上 _ => ()。這樣就加了不少樣板程式碼。\n不過我們可以使用 if let 以更精簡的方式寫出來，以下程式碼的行為就與範例 6-6 的 match 一樣：\nfn main() {\n    let config_max = Some(3u8);\n    if let Some(max) = config_max {\n        println!(\"最大值被設為 {}\", max);\n    }\n}\n\nif let 接收一個模式與一個表達式，然後用等號區隔開來。它與 match 的運作方式相同，表達式的意義與 match 相同，然後前面的模式就是第一個分支。\n在此例中的模式就是 Some(max)，然後 max 會綁定 Some 內的數值。我們就和 match 分支中使用 max 一樣，在 if let 區塊的本體中使用 max。如果數值沒有配對到模式，if let 中的程式碼就不會執行。\n使用 if let 可以少打些字、減少縮排以及不用寫多餘的樣板程式碼。不過你就少了 match 強制的徹底窮舉檢查。要何時選擇 match 還是 if let 得依據你在的場合是要做什麼事情，以及在精簡度與徹底檢查之間做取捨。\n換句話說，你可以想像 if let 是 match 的語法糖（syntax sugar），它只會配對一種模式來執行程式碼並忽略其他數值。\n我們也可以在 if let 之後加上 else，else 之後的程式碼區塊等同於 match 表達式中 _ 情形的程式碼區塊。這樣一來的 if let 和 else 組合就等同於 match 了。回想一下範例 6-4 的 Coin 列舉定義， Quarter 變體擁有數值 UsState。如果我們希望統計所有不是 25 美分的硬幣的同時，也能繼續回報 25 美分所屬的州的話，我們可以用 match 像這樣寫：\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --省略--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn main() {\n    let coin = Coin::Penny;\n    let mut count = 0;\n    match coin {\n        Coin::Quarter(state) => println!(\"此 25 美分所屬的州為 {:?}!\", state),\n        _ => count += 1,\n    }\n}\n\n或是我們也可以用 if let 和 else 表達式這樣寫：\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --省略--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn main() {\n    let coin = Coin::Penny;\n    let mut count = 0;\n    if let Coin::Quarter(state) = coin {\n        println!(\"此 25 美分所屬的州為 {:?}!\", state);\n    } else {\n        count += 1;\n    }\n}\n\n如果你的程式碼邏輯遇到使用 match 表達會太囉唆的話，記得 if let 也在你的 Rust 工具箱中供你使用。\n總結\n我們現在涵蓋了如何使用列舉來建立一系列列舉數值的自訂型別。我們展示了標準函式庫的 Option<T> 型別如何用型別系統來預防錯誤。當列舉數值其內有資料時，你可以依照你想處理的情況數量，使用 match 或 if let 來取出並使用那些數值。\n你的 Rust 程式碼現在能夠使用結構體與列舉來表達你所相關研究領域的概念了。在你的 API 建立自訂型別可以確保型別安全，編譯器會保證你的函式只會取得該函式預期的型別數值。\n接下來為了提供組織完善且直觀的的 API 供你的使用者使用，並只表達出使用者確切所需要的內容，我們需要瞭解 Rust 的模組。\n\n                    \n\n                    \n                        \n                            \n                                \n                            \n                            \n                                \n                            \n                        \n                    \n                \n            \n\n            \n                    \n                        \n                    \n                    \n                        \n                    \n            \n\n        \n\n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n    \n\n\n"
    },
    {
        "output": "URL: https://rust-book.junmajinlong.com/ch10/01_pattern_match_basis.html\nTITLE: 模式匹配的基本使用 - Rust入门秘籍\nCONTENT: \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n            \n            \n        \n\n        \n\n            \n                                \n                \n                    \n\n                    Rust入门秘籍\n                    \n                    \n                      博客\n                    \n\n                    \n                \n\n                \n\n                \n                \n\n                \n                    \n                        \n                        \n模式匹配的基本使用\n\nlet变量赋值时的模式匹配\n函数参数传值时的模式匹配\nmatch分支匹配\nif let\nwhile let\nfor迭代\n\n\n\n模式匹配的基本使用\n可在如下几种情况下使用模式匹配：\n\nlet变量赋值\n函数参数传值时的模式匹配\nmatch分支\nif let\nwhile let\nfor迭代的模式匹配\n\n\nlet变量赋值时的模式匹配\nlet变量赋值时的模式匹配：\n#![allow(unused)]\nfn main() {\nlet PATTERN = EXPRESSION;\n}\n变量是一种最简单的模式，变量名位于Pattern位置，赋值时的过程：将表达式与模式进行比较匹配，并将任何模式中找到的变量名进行对应的赋值。\n例如：\n#![allow(unused)]\nfn main() {\nlet x = 5;\nlet (x, y) = (1, 2);\n}\n第一条语句，变量x是一个模式，在执行该语句时，将表达式5赋值给找到的变量名x。变量赋值总是可以匹配成功。\n第二条语句，将表达式(1,2)和模式(x,y)进行匹配，匹配成功，于是为找到的变量x和y进行赋值：x=1,y=2。\n如果模式中的元素数量和表达式中返回的元素数量不同，则匹配失败，编译将无法通过。\n#![allow(unused)]\nfn main() {\nlet (x,y,z) = (1,2);  // 失败\n}\n\n函数参数传值时的模式匹配\n为函数参数传值和使用let变量赋值是类似的，本质都是在做模式匹配的操作。\n例如：\n#![allow(unused)]\nfn main() {\nfn f1(i: i32){\n  // xxx\n}\n\nfn f2(&(x, y): &(i32, i32)){\n  // yyy\n}\n}\n函数f1的参数i就是模式，当调用f1(88)时，88是表达式，将赋值给找到的变量名i。\n函数f2的参数&(x,y)是模式，调用f2( &(2,8) )时，将表达式&(2,8)与模式&(x,y)进行匹配，并为找到的变量名x和y进行赋值：x=2,y=8。\n\nmatch分支匹配\nmatch分支匹配的用法非常灵活，此处只做基本的用法介绍，后文还会继续深入其用法。\n它的语法为：\n#![allow(unused)]\nfn main() {\nmatch VALUE {\n  PATTERN1 => EXPRESSION1,\n  PATTERN2 => EXPRESSION2,\n  PATTERN3 => EXPRESSION3,\n}\n}\n其中=>左边的是各分支的模式，VALUE将与这些分支逐一进行匹配，=>右边的是各分支匹配成功后执行的代码。每个分支后使用逗号分隔各分支，最后一个分支的结尾逗号可以省略(但建议加上)。\nmatch会从前先后匹配各分支，一旦匹配成功则不再继续向下匹配。\n例如：\n#![allow(unused)]\nfn main() {\nlet x = (11, 22);\nmatch x {\n  (22, a) => println!(\"(22, {})\", a),   // 匹配失败\n  (a, b) => println!(\"({}, {})\", a, b), // 匹配成功，停止匹配\n  (a, 11) => println!(\"({}, 11)\", a),   // 匹配失败\n}\n}\n如果某分支对应的要执行的代码只有一行，则直接编写该行代码，如果要执行的代码有多行，则需加上大括号包围这些代码。无论加不加大括号，每个分支都是一个独立的作用域。\n因此，上述match的语法可衍生为如下两种语法：\n#![allow(unused)]\nfn main() {\nmatch VALUE {\n  PATTERN1 => code1,\n  PATTERN2 => code2,\n  PATTERN3 => code3,\n}\n\nmatch VALUE {\n  PATTERN1 => { \n    code line 1\n    clod line 2\n  },\n  PATTERN2 => { \n    code line 1\n    clod line 2\n  },\n  PATTERN3 => code1,\n}\n}\n另外，match结构自身也是表达式，它有返回值，且可以赋值给变量。match的返回值由每个分支最后执行的那行代码决定。Rust要求match的每个分支返回值类型必须相同，且如果是一个单独的match表达式而不是赋值给变量时，每个分支必须返回()类型。\n例如：\n#![allow(unused)]\nfn main() {\nlet x = (11,22);\n\n// 正确，match没有赋值给变量，分支必须返回Unit值()\nmatch x {\n  (a, b) => println!(\"{}, {}\", a, b), // 返回Unit值()\n  // 其他正确写法：{println!(\"{}, {}\", a, b);}, \n  // 错误写法：     println!(\"{}, {}\", a, b);, \n}\n\n// 正确，每个分支都返回Unit值()\nmatch x {\n  (a,11) => println!(\"{}\", a),  // 该分支匹配失败\n  (a,b) => println!(\"{}, {}\", a, b), // 将匹配该分支\n}\n\n// match返回值赋值给变量，每个分支必须返回相同的类型：i32\nlet y = match x {\n  (a,11) => {\n    println!(\"{}\", a);\n    a      // 该分支的返回值：i32类型\n  },\n  (a,b) => {\n    println!(\"{}, {}\", a, b);\n    a + b  // 该分支的返回值：i32类型\n  },\n};\n}\nmatch也经常用来穷举Enum类型的所有成员。此时要求穷尽所有成员，如果有遗漏成员，编译将失败。可以将_作为最后一个分支的PATTERN，它将匹配剩余所有成员。\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\nfn main(){\n  let dir = match Direction::Down {\n    Direction::Up => 1,\n    Direction::Down => 2,\n    Direction::Right => 3,\n    _ => 4,\n  };\n  println!(\"{}\", dir);\n}\n\nif let\nif let是match的一种特殊情况的语法糖：当只关心一个match分支，其余情况全部由_负责匹配时，可以将其改写为更精简if let语法。\n#![allow(unused)]\nfn main() {\nif let PATTERN = EXPRESSION {\n  // xxx\n}\n}\n这表示将EXPRESSION的返回值与PATTERN模式进行匹配，如果匹配成功，则为找到的变量进行赋值，这些变量在大括号作用域内有效。如果匹配失败，则不执行大括号中的代码。\n例如：\n#![allow(unused)]\nfn main() {\nlet x = (11, 22);\n\n// 匹配成功，因此执行大括号内的代码\n// if let是独立作用域，变量a b只在大括号中有效\nif let (a, b) = x {\n  println!(\"{},{}\", a, b);\n}\n\n// 等价于如下代码\nlet x = (11, 22);\nmatch x {\n  (a, b) => println!(\"{},{}\", a, b),\n  _ => (),\n}\n}\nif let可以结合else if、else if let和else一起使用。\n#![allow(unused)]\nfn main() {\nif let PATTERN = EXPRESSION {\n  // XXX\n} else if {\n  // YYY\n} else if let PATTERN = EXPRESSION {\n  // zzz\n} else {\n  // zzzzz\n}\n}\n这时候它们和match多分支类似。但实际上有很大的不同：使用match分支匹配时，要求分支之间是有关联(例如枚举类型的各个成员)且穷尽的，但Rust编译器不会检查if let的模式之间是否有关联关系，也不检查if let是否穷尽所有可能情况，因此，即使在逻辑上有错误，Rust也不会给出编译错误提醒。\n例如，下面是一个使用了if let..else if let的示例，该示例穷举了Enum类型的所有成员，还包括该枚举类型之外的情况，但即使去掉任何一个分支，也都不会报错。\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nfn main() {\n  let dir = Direction::Down;\n\n  if let Direction::Left = dir {\n    println!(\"Left\");\n  } else if let Direction::Right = dir {\n    println!(\"Right\");\n  } else {\n    println!(\"Up or Down or wrong\");\n  }\n}\n\nwhile let\n只要while let的模式匹配成功，就会一直执行while循环内的代码。\n例如：\n#![allow(unused)]\nfn main() {\nlet mut stack = Vec::new();\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n  println!(\"{}\", top);\n}\n}\n当stack.pop成功时，将匹配Some(top)成功，并将pop返回的值赋值给top，当没有元素可pop时，返回None，匹配失败，于是while循环退出。\n\nfor迭代\nfor迭代也有模式匹配的过程：为控制变量赋值。例如：\n#![allow(unused)]\nfn main() {\nlet v = vec!['a','b','c'];\nfor (idx, value) in v.iter().enumerate(){\n  println!(\"{}: {}\", idx, value);\n}\n}\n\n                    \n\n                    \n                        \n                            \n                                \n                            \n\n                            \n                                \n                            \n\n                        \n                    \n                \n            \n\n            \n                    \n                        \n                    \n\n                    \n                        \n                    \n            \n\n        \n\n\n\n\n        \n\n\n        \n        \n        \n\n        \n        \n        \n\n        \n        \n\n\n    \n\n"
    },
    {
        "output": "URL: https://rust-lang.tw/book-tw/ch18-00-patterns.html\nTITLE: 模式與配對 - Rust 程式設計語言\nCONTENT: \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n            \n            \n        \n\n        \n\n            \n                \n                \n                    \n\n                    Rust 程式設計語言\n\n                    \n                \n\n                \n                \n                \n\n                \n                    \n                        模式與配對\n模式（Patterns）是 Rust 中的特殊語法，能用來配對複雜與簡單的型別結構。搭配 match 表達式與其他結構來使用模式的話，可以給予你對程式控制流更多的掌控權。模式與以下元件組合而成：\n\n字面值（Literals）\n解構的陣列、列舉結構體或元組\n變數\n萬用字元（Wildcards）\n佔位符（Placeholders）\n\n模式的範例包含 x、(a, 3) 以及 Some(Color::Red)。當我們提到哪些模式是有效的時候，這些元件描述了我們要處理的資料形狀。我們的程式與其數值配對來決定我們的程式是否有取得正確的資料來繼續執行特定部分的程式碼。\n要使用模式，我們將其與一些數值做比較。如果模式配對到數值的話，我們就能在程式碼中使用該數值部分。回憶一下第六章中使用模式的 match 表達式，像是硬幣分類機器的範例。如果有數值符合模式的形狀，我們就可以使用這些命名的部分。如果沒有的話，配對相關的程式碼就不會執行。\n本章節會涵蓋所有與模式相關的內容。我們會討論能使用模式的地方，可反駁（refutable）與不可反駁（irrefutable）模式間的差別，以及不同種類的模式語法。在本章結束後，你便能知道如何使用模式來清楚表達許多概念。\n\n                    \n\n                    \n                        \n                            \n                                \n                            \n                            \n                                \n                            \n                        \n                    \n                \n            \n\n            \n                    \n                        \n                    \n                    \n                        \n                    \n            \n\n        \n\n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n    \n\n\n"
    },
    {
        "output": "URL: https://rust-lang.tw/book-tw/ch18-03-pattern-syntax.html\nTITLE: 模式語法 - Rust 程式設計語言\nCONTENT: \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n            \n            \n        \n\n        \n\n            \n                \n                \n                    \n\n                    Rust 程式設計語言\n\n                    \n                \n\n                \n                \n                \n\n                \n                    \n                        模式語法\n在此段落中，我們會收集所有模式中的有效語法，並討論你會怎麼使用它們。\n配對字面值\n如同你在第六章所見的，你可以直接使用字面值來配對模式，以下程式碼展示了一些範例：\nfn main() {\n    let x = 1;\n\n    match x {\n        1 => println!(\"一\"),\n        2 => println!(\"二\"),\n        3 => println!(\"三\"),\n        _ => println!(\"任意數字\"),\n    }\n}\n\n此程式碼會顯示「一」因為 x 的數值為 1。此語法適用於當你想要程式碼取得一個特定數值時，就馬上採取行動的情況。\n配對變數名稱\n變數名稱是能配對任何數值的不可反駁模式，而且我們在本書中已經使用非常多次。不過當你在 match 表達式中使用變數名稱時會複雜一點。因為 match 會初始一個新的作用域，作為 match 表達式部分模式的宣告變數會遮蔽 match 結構外同名的變數，和所有變數一樣。在範例 18-11 中，我宣告了一個變數叫做 x 其有數值 Some(5) 和一個變數 y 其有數值 10。然後我們建立一個數值 x 的 match 表達式。檢查配對分之中的模式並在最後用 println! 顯示出來，並嘗試在程式碼執行或進一步閱讀之前推測其會顯示的結果會為何。\n檔案名稱：src/main.rs\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"取得 50\"),\n        Some(y) => println!(\"配對成功，y = {y}\"),\n        _ => println!(\"預設情形，x = {:?}\", x),\n    }\n\n    println!(\"最後結果：x = {:?}, y = {y}\", x);\n}\n\n範例 18-11：match 表達式其中一個分支宣告了遮蔽的變數 y\n讓我們跑一遍看看當 match 執行時發生了什麼事。第一個配對分支並不符合 x 定義的數值，所以程式繼續執行下去。\n第二個配對分支宣告了一個新的變數叫做 y 來配對 Some 內的任何數值。因為我們位於 match 表達式內的新作用域，此新的 y 變數並不是我們一開始宣告有數值 10 的 y。這個新的 y 會配對 Some 內的任何數值，也就是 x 擁有的數值。因此，這個新的 y 會綁定 x 中 Some 的內部數值。該數值是 5，所以該分支的表達式就會執行並印出 配對成功，y = 5。\n如果 x 是 None 數值而非 Some(5) 的話，前兩個分支的模式都不會配對到，所以數值會配對到底線的分支。我們沒有在底線分支的模式中宣告 x 變數，所以表達式中的 x 仍然是外部沒有被遮蔽的 x 。在這樣的假設狀況下，match 會印出 預設情形，x = None。\n當 match 完成時，其作用域就會結束，所以作用域內的內部 y 也會結束。最後一個 println! 會顯示 最後結果：x = Some(5), y = 10。\n要建立個能對外部 x 與 y 數值做比較的 match 表達式而非遮蔽變數的話，我們需要改用條件配對守護。我們會在之後的「提供額外條件的配對守護」段落討論配對守護。\n多重模式\n在 match 表達式中，你可以使用 | 語法來配對數個模式，這是 OR（或） 運算子模式。舉例來說，以下程式碼會配對 x 的數值到配對分支，第一個分支有個 OR 的選項，代表如果 x 的數值配對的到分支中任一數值的話，該分支的程式碼就會執行：\nfn main() {\n    let x = 1;\n\n    match x {\n        1 | 2 => println!(\"一或二\"),\n        3 => println!(\"三\"),\n        _ => println!(\"任意數字\"),\n    }\n}\n\n此程式碼會印出 一或二。\n透過 ..= 配對數值範圍\n..= 語法讓我們可以配對一個範圍內包含的數值。在以下程式碼中，當模式配對的到範圍內的任何數值時，該分支就會執行：\nfn main() {\n    let x = 5;\n\n    match x {\n        1..=5 => println!(\"一到五\"),\n        _ => println!(\"其他\"),\n    }\n}\n\n如果 x 是 1、2、3、4 或 5 的話，第一個分支就能配對到。在配對多重數值時，此語法比使用 | 運算子來表達相同概念還輕鬆得多。如果我們使用 | 的話，就得指明 1 | 2 | 3 | 4 | 5 而非 1..=5。指定範圍相對就簡短許多，尤其是如果我們得配對像是數字 1 到 1,000 的話！\n編譯器會在編譯時檢查範圍是否為空，然後因為char 與數字數值是 Rust 中唯一能判斷範圍是否為空的型別，所以範圍只允許使用數字或 char 數值。\n以下是使用 char 數值作為範圍的範例：\nfn main() {\n    let x = 'c';\n\n    match x {\n        'a'..='j' => println!(\"前半部 ASCII 字母\"),\n        'k'..='z' => println!(\"後半部 ASCII 字母\"),\n        _ => println!(\"其他\"),\n    }\n}\n\nRust 可以知道 'c' 有包含在第一個模式的範圍內，所以印出 前半部 ASCII 字母。\n解構拆開數值\n我們可以使用模式來解構結構體、列舉與元組，以便使用這些數值的不同部分。讓我們依序來看看。\n解構結構體\n範例 18-12 有個結構體 Point 其有兩個欄位 x 與 y，我們可以在 let 陳述式使用模式來拆開它。\n檔案名稱：src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n\n範例 18-12：解構結構體欄位成獨立的變數\n此程式碼建立了變數 a 與 b 來配對 p 結構體中 x 與 y 的欄位。此範例顯示出模式中的變數名稱不必與結構體中的欄位名稱一樣。不過通常還是建議變數名稱與欄位名稱一樣，以便記得哪些變數來自於哪個欄位。因為用變數名稱來配對欄位是十分常見的，而且因為 let Point { x: x, y: y } = p; 會包含許多重複部分，所以配對結構體欄位的模式有另一種簡寫方式，你只需要列出結構體欄位的名稱，這樣從結構體建立的變數名稱就會有相同名稱。範例 18-13 顯示的程式碼行為與範例 18-12 一樣，但是在 let 模式建立的變數是 x 與 y 而非 a 與 b。\n檔案名稱：src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}\n\n範例 18-13：使用結構體欄位簡寫來解構結構體欄位\n此程式碼建立了變數 x 與 y 並配對到變數 p 的 x 與 y 欄位。結果就是變數 x 與 y 會包含 p 結構體中的數值。\n我們也可以將字面值數值作為結構體模式中的一部分，而不用建立所有欄位的變數。這樣做我們可以在解構一些欄位成變數時，測試其他欄位是否有特定數值。\n在範例 18-14 的 match 表達式將 Point 的數值分成三種情況：位於 x 軸的點（也就是 y = 0）、位於 y 軸的點（x = 0）或不在任何軸的點。\n檔案名稱：src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"位於 x 軸的 {x}\"),\n        Point { x: 0, y } => println!(\"位於 y 軸的 {y}\"),\n        Point { x, y } => println!(\"不在任一軸：({x}, {y})\"),\n    }\n}\n\n範例 18-14：解構並配對模式中的字面值數值\n第一個分支透過指定 y 欄位配對字面值為 0 來配對任何在 x 軸上的點。此模式仍然會建立變數 x 能讓我們在此分支的程式碼中使用。\n同樣地，第二個分支透過指定 x 欄位配對字面值為 0 來配對任何在 y 軸上的點，並建立擁有 y 欄位數值的變數 y。第三個分支沒有指定任何字面值，所以它能配對任何其他 Point 並建立 x 與 y 欄位對應的變數。\n在此例中，數值 p 會配對到第二個分支，因為其 x 為 0，所以此程式碼會印出 位於 y 軸的 7。\n回想一下 match 表達式在找到第一個符合的配對模式之後就會停止檢查分支，所以就算 Point { x: 0, y: 0} 真的在 x 軸與 y 軸，此程式碼也只會印出 位於 x 軸的 0。\n解構列舉\n我們已經在本書中之前的章節就解構過列舉（比如第六章的範例 6-5）。但我們還沒談到的細節是解構列舉的模式必須與列舉定義中其所儲存的資料相符。作為示範，我們在範例 18-15 中使用範例 6-2 的 Message 列舉並寫一個 match 來提供會解構每個內部數值的模式。\n檔案名稱：src/main.rs\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"Quit 變體沒有資料能解構。\");\n        }\n        Message::Move { x, y } => {\n            println!(\"Move 往 x 的方向為 {x} 且往 y 的方向為 {y}\");\n        }\n        Message::Write(text) => println!(\"文字訊息：{text}\"),\n        Message::ChangeColor(r, g, b) => {\n            println!(\"變更顏色為紅色 {r}、綠色 {g} 與藍色 {b}\")\n        }\n    }\n}\n\n範例 18-15：解構持有不同種數值的列舉變體\n此程式碼會印出 變更顏色為紅色 0、綠色 160 與藍色 255。請嘗試變更 msg 的數值來看看其他分支的程式碼會執行出什麼。\n對於像是 Message::Quit 這種沒有任何資料的列舉，我們無法進一步解構出任何資料。我們只能配對其本身的數值 Message::Quit，所以在該模式中沒有任何變數。\n對於像是 Message::Move 這種類結構體列舉變體，我們可以使用類似於指定配對結構體的模式。在變體名稱之後，我們加上大括號以及列出欄位名稱作為變數，讓我們能拆成不同部分並在此分支的程式碼中使用。我們在此使用範例 18-13 一樣的簡寫形式。\n對於像是 Message::Write 這種持有一個元素，以及 Message::ChangeColor 這種持有三個元素的類元組列舉變體，我們可以使用類似於配對元組的模式。模式中的變數數量必須與我們要配對的變體中元素個數相符。\n解構巢狀結構體與列舉\n到目前為止，我們所有的結構體或列舉配對範例的深度都只有一層，但配對也可以用於巢狀項目中！舉例來說，我們可以重構範例 18-15 的程式碼，在 ChangeColor 中支援 RGB 與 HSV 顏色，如範例 18-16 所示。\nenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\"變更顏色為紅色 {r}、綠色 {g} 與藍色 {b}\");\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\"變更顏色為色相 {h}、飽和度 {s} 與明度 {v}\");\n        }\n        _ => (),\n    }\n}\n\n範例 18-16：配對巢狀列舉\nmatch 表達式的第一個分支模式會配對包含 Color::Rgb 變體的 Message::ChangeColor 列舉變體，然後該模式會綁定內部三個 i32 數值。第二個分支也是配對到 Message::ChangeColor 列舉變體，但是內部列舉會改配對 Color::Hsv。我們可以在一個 match 表達式指定這些複雜條件，即使有兩個列舉參與其中。\n解構結構體與元組\n我們甚至可以用更複雜的方式來混合、配對並巢狀解構模式。以下範例展示了一個複雜的結構模式，其將一個結構體與一個元組置於另一個元組中，並將所有的原始數值全部解構出來：\nfn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n}\n\n此程式碼讓我們將複雜的型別拆成部分元件，讓我們可以分別使用我們有興趣的數值。\n解構模式是個能方便使用部分數值的方式，比如結構體每個欄位分別獨立的數值。\n忽略模式中的數值\n你已經看過有時候在模式中忽略數值是很實用的，像是在 match 中的最後一個分支能捕獲所有剩餘用不到的可能數值。模式有一些方式可以忽略所有或部分數值：使用（你已經看過的） _ 模式、在其他模式使用 _ 模式、在名稱前加上底線，或是使用 .. 來忽略剩餘部分的數值。讓我們來探討如何與為何要使用這些模式吧。\n透過 _ 忽略整個數值\n我們使用底線在來作為萬用字元（wildcard）模式，這會配對任何數值，但不會綁定其值。雖然底線 _ 模式特別適合作為 match 表達式最後一個分支，但我們可以將它用在任何模式中，包含函式參數，如範例 18-17 所示。\n檔案名稱：src/main.rs\nfn foo(_: i32, y: i32) {\n    println!(\"此程式碼只使用了參數 y：{}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n\n範例 18-17：在函式簽名中使用 _\n此程式碼會完全忽略第一個引數傳入的數值 3，並會印出 此程式碼只使用了參數 y：4。\n在大多數情況中如果當你不再需要特定函式參數的話，你會直接變更簽名讓它不會包含沒有使用到的參數。但忽略函式參數在某些場合會很有用。舉例來說，當你實作的特徵有個特定的型別簽名，但是你實作的函式本體不需要其中某個參數。這樣你就不會被編譯器警告沒有使用到的函式參數，會當做你有使用參數名稱一樣。\n透過巢狀 _ 忽略部分數值\n我們也可以在其他模式中使用 _ 來忽略部分數值。舉例來說，當我們只想測試部分數值，但不會用到執行的程式碼中其他部分數值的情況。範例 18-18 的程式碼負責管理設定值的數值。業務要求使用者不能覆寫已經存在的自訂數訂值，但可以取消設定值，也可以在目前未設定時提供數值。\nfn main() {\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) => {\n            println!(\"無法覆寫已經存在的自訂數值\");\n        }\n        _ => {\n            setting_value = new_setting_value;\n        }\n    }\n\n    println!(\"設定為 {:?}\", setting_value);\n}\n\n範例 18-18：當我們不需要使用 Some 內部數值時，在模式中使用底線來配對 Some 變體\n此程式碼會印出 無法覆寫已經存在的自訂數值 接著印出 設定為 Some(5)。在第一個配對分支中，我們不需要去配對或使用任一 Some 變體內的數值，但我們的確需要檢測  setting_value 與 new_setting_value 是否都為 Some 變體的情況。在此情況下，我們印出為何不能變更 setting_value，且不讓它被改變。\n在其他所有情況下（無論是 setting_value 還是 new_setting_value 為 None），我們用第二個分支的 _ 模式來配對，我們讓 new_setting_value 變成 setting_value。\n我們也可以在同個模式中的多重位置使用底線來忽略特定數值。範例 18-19 忽略了有五個元素的元組中第二個與第四個數值。\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) => {\n            println!(\"一些數字：{first}、{third}、{fifth}\")\n        }\n    }\n}\n\n範例 18-19：忽略元組中數個位置\n此程式碼會印出 一些數字：2、8、32，然後數值 4 與 16 會被忽略。\n在名稱前加上 _ 來忽略未使用的變數\n如果你建立了一個變數但沒有在任何地方使用到它，Rust 通常會提出警告，因為未使用的變數可能會是個錯誤。但有時候先建立個你還沒有使用的變數是很有用的，像是你還在寫原型或是才剛開個專案而已。在這種場合，你可以在尚未使用的變數名稱前加上底線，來告訴 Rust 不用提出警告。在範例 18-20 中，我們建立了兩個未使用的變數，但當我們編譯此程式碼時，我們應該會只收到其中一個的警告而已。\n檔案名稱：src/main.rs\nfn main() {\n    let _x = 5;\n    let y = 10;\n}\n\n範例 18-20：在變數名稱前加上底線來避免未使用變數的警告\n我們在此收到沒有使用變數 y 的警告，但是我們沒有收到 _x 的警告。\n注意到只使用 _ 與在名稱前加上底線之間是有些差別的。_x 仍會綁定數值到變數中，但 _ 不會做任何綁定。為了展示這樣的區別是有差的，我們用範例 18-21 來展示一個錯誤。\nfn main() {\n    let s = Some(String::from(\"哈囉！\"));\n\n    if let Some(_s) = s {\n        println!(\"發現字串\");\n    }\n\n    println!(\"{:?}\", s);\n}\n\n範例 18-21：以底線開頭的未使用變數仍會綁定數值，因而造成數值所有權被移動\n我們會收到錯誤，因為 s 的數值仍會被移至 _s，讓我們無法再使用 s。不過只使用底線的話就不會綁定數值。範例 18-22 就能夠編譯不會產生任何錯誤，因為 s 沒有移至 _。\nfn main() {\n    let s = Some(String::from(\"哈囉！\"));\n\n    if let Some(_) = s {\n        println!(\"發現字串\");\n    }\n\n    println!(\"{:?}\", s);\n}\n\n範例 18-22：使用底線不會綁定數值\n此程式碼就能執行，因為我們沒有將 s 綁定給誰，它沒被移動。\n透過 .. 忽略剩餘部分數值\n對於有許多部分的數值，我們可以用 .. 語法來使用特定部分，然後忽略剩餘部分，來避免需要對每個要忽略的數值都得加上底線。.. 模式會忽略模式中剩餘尚未配對的任何部分數值。在範例 18-23 中，我們有個 Point 結構體存有三維空間中的座標。而在 match 表達式中，我們想要只處理 x 座標並忽略 y 與 z 欄位的數值。\nfn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n        z: i32,\n    }\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n\n    match origin {\n        Point { x, .. } => println!(\"x 為 {}\", x),\n    }\n}\n\n範例 18-23：透過使用 .. 來忽略 Point 中除了 x 以外的所有數值\n我們列出 x 數值接著只包含 .. 模式。這比需要列出 y: _ 和 z: _ 還要快，尤其是當我們要處理有許多欄位的結構體，但只需要用到一或兩個欄位的狀況下。\n.. 語法會擴展其所有所需得數值。範例 18-24 展示如何在元組使用 ..。\n檔案名稱：src/main.rs\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"一些數字：{first}、{last}\");\n        }\n    }\n}\n\n範例 18-24：只配對元組中的第一個與最後一個數值，並忽略其他所有數值\n在此程式碼中，第一個與最後一個數值會配對到 first 與 last。.. 會配對並忽略中間所有數值。\n然而，使用 .. 必須是明確的。如果 Rust 無法確定是哪些數值要配對，而哪些是要忽略的話，它會回傳錯誤給我們。範例 18-25 含糊地使用了 ..，所以它無法編譯。\n檔案名稱：src/main.rs\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) => {\n            println!(\"一些數字：{}\", second)\n        },\n    }\n}\n\n範例 18-25：嘗試含糊地使用 ..\n當我們編譯此範例時，我們會得到此錯誤：\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror: `..` can only be used once per tuple pattern\n --> src/main.rs:5:22\n  |\n5 |         (.., second, ..) => {\n  |          --          ^^ can only be used once per tuple pattern\n  |          |\n  |          previously used here\n\nerror: could not compile `patterns` due to previous error\n\nRust 不可能會知道在配對 second 之前要忽略多少元組中的數值，以及在之後得再忽略多少數值此程式碼可以代表我們想要忽略 2、綁定 second 到 4 然後忽略 8、16 和 32；或者我們想要忽略 2 和 4、綁定 second 到 8 然後忽略 16 和 32，以及更多可能。變數名稱 second 對 Rust 沒有任何特別意義，所以我們得到編譯錯誤，因為像這樣在兩個地方使用 .. 是含糊不清的。\n提供額外條件的配對守護\n配對守護（match guard）是個在 match 分支之後額外指定的 if 條件，此條件也必須符合配對才能選擇該分支。配對守護適用於比單獨模式所能表達的還複雜的情況。\n該條件能使用配對建立的變數。範例 18-26 展示 match 的第一個分支有個模式 Some(x) 並使用配對守護 if x % 2 == 0（如果數字為偶數就會成立）。\nfn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println!(\"數字 {x} 是偶數\"),\n        Some(x) => println!(\"數字 {x} 是奇數\"),\n        None => (),\n    }\n}\n\n範例 18-26：對模式加上配對守護\n此範例會印出 數字 4 是偶數。當 num 與第一個分支做比較時，它會配對到，因為 Some(4) 能與 Some(x) 做配對。然後配對守護會檢查數值 x 除以 2 的餘數是否為 0，然後因為的確如此，所以就選擇了第一個分支。\n如果 num 為 Some(5) 的話，第一個分支的配對守護則會是否，因為 5 除以 2 的餘數為 1，並不等於 0。Rust 就會接著檢查第二條分支，然後因為第二條分支沒有任何配對守護所以能配對到任何 Some 變體。\n在模式中沒有任何方式能夠表達 if x % 2 == 0，所以配對守護讓我們能夠有能力表達此邏輯。這種額外的表達能力的缺點是，編譯器對有配對守護的分支就不會窮舉檢查。\n在範例 18-11 中，我們提到我們可以使用模式配對來解決我們的模式遮蔽問題。回想一下 match 表達式中使用的是模式內建立的新變數，而不是使用 match 外部的變數。該新變數會讓我們無法測試外部變數的數值。範例 18-27 展示我們如何使用配對守護來修正此問題。\n檔案名稱：src/main.rs\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"取得 50\"),\n        Some(n) if n == y => println!(\"配對成功，n = {n}\"),\n        _ => println!(\"預設情形，x = {:?}\", x),\n    }\n\n    println!(\"最後結果：x = {:?}, y = {y}\", x);\n}\n\n範例 18-27：使用配對守護來測試與外部變數是否相等\n此程式碼現在會印出 預設情形，x = Some(5)。第二個模式中沒有宣告新的變數 y 來遮蔽外部的 y，意味著我們可以在配對守護中使用外部的 y。我們不再指定模式為 Some(y)，因為這樣會遮蔽外部的 y，我們改指定成 Some(n)。這樣建立了一個新的變數 n 且不會遮蔽任何事物，因為 match 外部沒有任何變數 n。\n配對守護 if n == y 不屬於模式，因此不會宣告任何新變數。此 y 就是外部的 y 而非新遮蔽的 y，而且我們可以透過將 n 與 y 做比較來檢查數值是否與外部 y 的數值相等。\n你也可以在配對守護中使用 OR 運算子 | 來指定多重模式，配對守護的條件會套用在所有的模式中。範例 18-28 顯示了結合配對守護與使用 | 模式之間的優先層級（precedence）。此例中的重點部分在於 if y 配對守護能套用在 4、5 與 6，而不是只有 6 會用到 if y。\nfn main() {\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y => println!(\"是\"),\n        _ => println!(\"否\"),\n    }\n}\n\n範例 18-28：結合數個模式與配對守護\n此配對條件表示該分支只有在數值 x 等於 4、5 或 6，以及如果 y 為 true 時才算配對到。當此程式碼執行時，第一個分支的模式有配對到，因為 x 為 4，但是配對守護 if y 為否，所以不會選擇第一個分支。程式碼會移動到第二個分支，然後程式會配對到並印出 no。原因在於 if 條件會套用到整個模式 4 | 5 | 6，而不是只有最後一個數值 6。換句話說，配對守護與模式之間的優先層級會像是這樣：\n(4 | 5 | 6) if y => ...\n\n而不是這樣：\n4 | 5 | (6 if y) => ...\n\n在執行此程式碼之後，優先層級的行為就很明顯了，如果配對守護只會用在由 | 運算子指定數值列表中最後一個數值的話，該分支應該要能配對到並讓程式印出 是。\n@ 綁定\nAt 運算子（@）能讓我們在測試某個數值是否配對的到一個模式的同時，建立出一個變數來持有該數值。在範例 18-29 我們想要測試 Message::Hello 的 id 欄位是否位於 3..=7 的範圍中。我們也想要將該數值綁定到變數 id_variable 之中，讓我們可以在該分支對應的程式碼中使用它。我們可以將此變數命名為與欄位同名的 id，但在此例中我們會使用不同名稱。\nfn main() {\n    enum Message {\n        Hello { id: i32 },\n    }\n\n    let msg = Message::Hello { id: 5 };\n\n    match msg {\n        Message::Hello {\n            id: id_variable @ 3..=7,\n        } => println!(\"id 在此範圍中：{}\", id_variable),\n        Message::Hello { id: 10..=12 } => {\n            println!(\"id 在其他範圍中\")\n        }\n        Message::Hello { id } => println!(\"找到其他 id：{}\", id),\n    }\n}\n\n範例 18-29：使用 @ 來在測試時綁定模式中的數值\n此範例會印出 id 在此範圍中：5。透過在範圍 3..=7 之前指定 id_variable @，我們能獲取要配對到範圍的數值，並同時測試該數值是否有配對到範圍模式。\n在第二個分支中，我們只有在模式中指定範圍，該分支對應的程式碼就沒有變數能包含 id 欄位的實際數值。id 欄位數值可能是 10、11 或 12，但此模式的程式碼不會知道其值為何。該模式程式碼無法使用 id 欄位的數值，因為我們沒有將 id 數值存為變數。\n在最後一個分支中，我們指定沒有限制範圍的變數，我們有能在分支程式碼中使用的有效變數 id。原因是因為我們使用了結構體欄位簡寫語法。不過我們在此分支沒有像前兩個分支進行任何對 id 欄位的測試，任何數值都會配對到此模式。\n使用 @ 讓我們能在一個模式中測試數值並將其儲存至變數。\n總結\nRust 的模式對於分辨不同種資料來說非常實用。當在 match 表達式中使用時，Rust 確保你的模式有涵蓋所有可能數值，不然你的程式就不會編譯通過。在 let 陳述式與函式參數中的模式使它們的結構更實用，在能夠解構數值成更小部分的同時賦值給變數。我們能夠建立簡單或複雜的模式來滿足我們的需求。\n接下來，在本書的倒數第二章中，我們要來看 Rust 眾多特色中的一些進階部分。\n\n                    \n\n                    \n                        \n                            \n                                \n                            \n                            \n                                \n                            \n                        \n                    \n                \n            \n\n            \n                    \n                        \n                    \n                    \n                        \n                    \n            \n\n        \n\n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n    \n\n\n"
    },
    {
        "output": "URL: https://rust-lang.tw/book-tw/ch18-01-all-the-places-for-patterns.html\nTITLE: 所有能使用模式的地方 - Rust 程式設計語言\nCONTENT: \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n            \n            \n        \n\n        \n\n            \n                \n                \n                    \n\n                    Rust 程式設計語言\n\n                    \n                \n\n                \n                \n                \n\n                \n                    \n                        所有能使用模式的地方\n模式常出現於 Rust 中數個位置，而你已經不經意使用了很多模式了！此段落會介紹所有模式能有效出現的地方。\nmatch 分支\n如同第六章所討論過的，我們可以在 match 表達式中的分支使用模式。正式來說，match 表達式的定義為 match 關鍵字加上一個要配對的數值，然後會有一或數個包含模式的分支，以及如果數值配對到該分支模式之後要執行的表達式，如以下所示：\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n\n舉例來說，以下是範例 6-5 的變數 x 對 Option<i32> 進行配對：\nmatch x {\n    None => None,\n    Some(i) => Some(i + 1),\n}\n\n在此  match 表達式中的模式有 None 與 Some(i)，顯示在每個箭頭的左方。\nmatch 表達式有個要求就是它們必須是徹底的（exhaustive），所有 match 表達式數值可能的結果都必須涵蓋到。其中一個確保你有考慮到所有可能性的方式是在最後一個分支使用捕獲模式，命名一個能配對任何數值的變數就絕不會失敗，因此可以涵蓋剩餘的情況。\n還有一個特定模式 _ 可以獲取任意可能情況，但它不會綁定到變數中，所以它也很常用在最後的配對分支。舉例來說，_ 模式就很適合用來忽略任何沒指明的數值。我們會在本章之後的 「忽略模式中的數值」段落談到更多 _ 的細節。\nif let 條件表達式\n在第六章中我們介紹了如何使用 if let 表達式，它等同於只配對一種情況的 match 表達式，主要作為更簡潔的語法。此外，if let 可以再加上 else 來包含如果 if let 模式不符的話能執行的程式碼。\n範例 18-1 展示了我們能夠混合並配對 if let、else if 與 else if let 表達式。這樣做可以比 match 表達式還來得有彈性，因為 match 只能有一個數值與模式們配對。另外，Rust 也不需要 if let、else if 與 else if let 分支之間的條件彼此要有關聯。\n範例 18-1 的程式碼依據一系列的條件檢查來決定背景顏色該為何。在此例中，我們建立一個寫死的變數數值，在實際程式中應該會由使用者輸入。\n檔案名稱：src/main.rs\nfn main() {\n    let favorite_color: Option<&str> = None;\n    let is_tuesday = false;\n    let age: Result<u8, _> = \"34\".parse();\n\n    if let Some(color) = favorite_color {\n        println!(\"使用你最喜歡的顏色{color}作為背景\");\n    } else if is_tuesday {\n        println!(\"星期二就用綠色！\");\n    } else if let Ok(age) = age {\n        if age > 30 {\n            println!(\"使用紫色作為背景顏色\");\n        } else {\n            println!(\"使用橘色作為背景顏色\");\n        }\n    } else {\n        println!(\"使用藍色作為背景顏色\");\n    }\n}\n\n範例 18-1：混合 if let、else if、else if let 與 else\n如果使用者指定的最喜歡的顏色，該顏色就是背景顏色。如果沒有喜歡的顏色且今天是星期二的話，背景顏色就是綠色。如果使用者用字串指定他們的年齡且可以成功轉換成數字的話，背景顏色依據數字結果就是紫色或橘色。如果以上條件都不符合的話，背景顏色就是藍色。\n這樣的條件結構讓我們可以支援複雜的需求。透過我們在此寫死的數值，此例會印出 使用紫色作為背景顏色。\n你可以看到 if let 也能如同 match 的分支一樣遮蔽變數，if let Ok(age) = age 這行就產生了新的遮蔽變數 age 來包含 Ok 變體內的數值。這意味著我們需要將 if age > 30 的條件放在區塊內，我們不能組合這兩個條件成 if let Ok(age) = age && age > 30。遮蔽的 age 在大括號開始之後的新作用域才有效，此時才能與 30 做比較。\n使用 if let 表達式的缺點是編譯器不會徹底檢查，而 match 表達式則會。如果我們省略最後一個 else 區塊而因此忘了處理一些情況，編譯器不會警告我們這種可能的邏輯錯誤。\nwhile let 條件迴圈\n與 if let 的結構類似，while let 條件迴圈允許 while 迴圈只要在模式持續配對符合的情況下一直執行。在範例 18-2 的例子我們寫了一個 while let 迴圈使用向量做為堆疊，並以數值被插入向量時相反的順序印出它們。\nfn main() {\n    let mut stack = Vec::new();\n\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n\n    while let Some(top) = stack.pop() {\n        println!(\"{}\", top);\n    }\n}\n\n範例 18-2：使用 while let 迴圈，且只要 stack.pop() 有回傳 Some 就持續印出數值\n此範例會依序顯示 3、2 然後是 1。pop 方法會取得向量最後一個數值並回傳 Some(value)。如果向量是空的，pop 就回傳 None。只要 pop 有回傳 Some，while 迴圈就會持續執行其區塊中的程式碼。當 pop 回傳 None 時，迴圈就會結束。我們可以使用 while let 來取得堆疊彈出的每個數值。\nfor 迴圈\n在 for 迴圈中，for 關鍵字之後的數值就是模式。舉例來說，在 for x in y 中 x 就是模式範例 18-3 展示了如何在 for 迴圈使用模式來解構或拆開一個 for 迴圈中的元組。\nfn main() {\n    let v = vec!['a', 'b', 'c'];\n\n    for (index, value) in v.iter().enumerate() {\n        println!(\"{} 位於索引 {}\", value, index);\n    }\n}\n\n範例 18-3：使用模式來解構 for 迴圈中的元組\n範例 18-3 的程式碼會顯示以下結果：\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.52s\n     Running `target/debug/patterns`\na 位於索引 0\nb 位於索引 1\nc 位於索引 2\n\n我們使用 enumerate 方法來配接一個疊代器來產生一個數值與該數值在疊代器中的索引，並放入元組中。第一個產生的數值爲元組 (0, 'a')。當此數值配對到 (index, value) 模式時，index 會是 0 而 value 會是 'a'，並印出第一行的輸出。\nlet 陳述式\n在本章節之前，我們只有告訴你模式能用在 match 和 if let，但事實上我們在其他地方也早就使用過模式了，這包含 let 陳述式。舉例來說，請看看以下這個使用 let 賦值變數的直白例子：\n#![allow(unused)]\nfn main() {\nlet x = 5;\n}\n\n每次當你像這樣使用 let 陳述式時，你就已經在使用模式了，儘管你還沒有察覺到！所以更正式地來說，let 陳述式是這樣定義的：\nlet PATTERN = EXPRESSION;\n\n像 let x = 5; 這樣的陳述式中變數名稱會位於 PATTERN 的位置，變數名稱恰好是種特別簡單的模式。Rust 會將表達式與模式做比較，並賦值給它找到的任何名稱。所以在 let x = 5; 的範例中，x 是個模式並表示「將配對到的數值綁定給變數 x」。因為名稱 x 就是整個模式，此模式實際上等同於「將任何數值綁定給變數 x，無論該數值為何」。\n為了更清楚理解 let 怎麼使用模式配對，請參考範例 18-4，這對 let 使用模式來解構一個元組。\nfn main() {\n    let (x, y, z) = (1, 2, 3);\n}\n\n範例 18-4：使用模式來解構元組，並同時建立三個變數\n我們在此用一個元組來配對一個模式。Rust 會將數值 (1, 2, 3) 與模式 (x, y, z) 做比較，並看出數值能配對到模式中，所以 Rust 將 1 綁定給 x、2 給 y 然後 3 給 z。你可以把此元組模式想成是三個獨立的變數模式組合在一起。\n如果模式中的元素個數與元組中的元素個數不符合的話，整體型別就無法配對，所以我們會得到編譯錯誤。舉例來說，範例 18-5 嘗試將有三個元素的元組解構到兩個變數中，這樣就無法成功。\nfn main() {\n    let (x, y) = (1, 2, 3);\n}\n\n範例 18-5：錯誤的模式結構，因為變數數量與元組元素個數不符\n嘗試編譯此程式碼的話，會得到此型別錯誤：\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0308]: mismatched types\n --> src/main.rs:2:9\n  |\n2 |     let (x, y) = (1, 2, 3);\n  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`\n  |         |\n  |         expected a tuple with 3 elements, found one with 2 elements\n  |\n  = note: expected tuple `({integer}, {integer}, {integer})`\n             found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `patterns` due to previous error\n\n要修正錯誤的話，我們可以使用 _ 或 .. 來忽略元組中的一或數個數值，你會在「忽略模式中的數值」段落中瞭解更多詳情。如果問題出在於我們模式中有太多變數的話，解決辦法就是移除些變數使變數數量等同於元組元素個數，讓型別可以配對。\n函式參數\n函式參數也可以是模式。範例 18-6 的程式碼宣告了一個函式叫做 foo 來接收一個參數叫做 x 其型別為 i32，現在這看起來你應該都還很熟悉。\nfn foo(x: i32) {\n    // 內部的程式碼\n}\n\nfn main() {}\n\n範例 18-6：在參數中使用模式的函式簽名\nx 的部分就是模式！就如同我們在 let 所做的一樣，我們可以在函式引數中使用模式來配對元組，範例 18-7 將傳遞給函式的元組拆為不同數值。\n檔案名稱：src/main.rs\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"目前位置：({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}\n\n範例 18-7：函式透過參數來解構元組\n此程式碼會顯示 目前位置：(3, 5)。數值 &(3, 5) 能配對到模式 &(x, y)，所以 x 會是數值 3 而 y 會是數值 5。\n我們還可以在閉包參數列表中像函式參數列表這樣使用模式，因為第十三章就提過閉包類似於函式。\n到目前為止，你已經見過許多使用模式的方式，但模式在我們能使用的地方並不都會有相同的行為。在某些地方，模式必須是不可反駁的（irrefutable），而在其他場合它們則是可反駁的（refutable）。接下來我們會來討論這兩個概念。\n\n                    \n\n                    \n                        \n                            \n                                \n                            \n                            \n                                \n                            \n                        \n                    \n                \n            \n\n            \n                    \n                        \n                    \n                    \n                        \n                    \n            \n\n        \n\n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n    \n\n\n"
    }
    ]
---

system:
### Role Description:

You are a Rust software development partner, specializing in assisting professional developers with any questions, suggestions, or clarifications related to Rust. Your interaction style is relaxed and friendly, like chatting between developer friends. Keep responses concise and direct, providing explanations only when requested.

### Interaction Structure:

1. **Greet and Connect:** Start with a friendly greeting to set a relaxed atmosphere.
2. **Prompt Specific Query:** Ask for specific details about the Rust issue or topic they need help with.
3. **Provide Direct Assistance:** Respond concisely to queries; avoid lengthy explanations unless specifically asked.
4. **Offer Further Help:** After providing assistance, ask if there's anything else related to Rust they need help with.
5. **End Interaction:** Conclude the conversation with a friendly closing remark, encouraging them to reach out anytime they need further assistance.
6. **Language**: Respond in the same language as the user. BUT when the user uses 中文: (Respond in 正體中文zh-tw not 簡體中文zh-cn. Use full-width punctuation marks and always add a space between Chinese characters and alphanumeric characters. 專有名詞使用台灣正體中文常用術語。) Default to English if unclear. 

### AI Operation Guide:

- **Quick Response:** Aim for quick and straightforward answers to mimic real-time chat between friends.
- **Casual Language Use:** Maintain an informal and approachable tone throughout the interaction.
- **Provide Reference Links:** Always provide users with reference links when citing knowledge. Note: The link must genuinely exist in the referenced material; do not fabricate a link.
- **Wait for Prompting:** Do not elaborate on topics unless users request more detailed information.
- **Feedback Mechanism**: Encourage users to provide feedback on the solutions or information provided.

### Sample Prompt:

Hey! What Rust challenge are you tackling today? 🦀

### Additional Prompt:

Got it! Need help with anything else related to Rust? Or do you have something else on your mind?

### Closing Prompt:

Great! If you need more Rust help feel free to reach out anytime. Happy Coding! 👋


### Reference knowledge

Please refer to the following information to answer.

{{knowledge}}

/---
ALWAYS PROVIDE USERS WITH REFERENCE LINKS IF THEY ARE RELATED TO THE USER'S QUESTION OR WERE USED IN YOUR RESPONSE.
ALWAYS PROVIDE USERS WITH REFERENCE LINKS IF THEY ARE RELATED TO THE USER'S QUESTION OR WERE USED IN YOUR RESPONSE.
ALWAYS PROVIDE USERS WITH REFERENCE LINKS IF THEY ARE RELATED TO THE USER'S QUESTION OR WERE USED IN YOUR RESPONSE.

assistant:
🤖 遇見你的最佳 Rust 助手 — Rust AI Buddy！
💻 我能夠即時解答你的 Rust 相關問題，提供程式碼優化建議，並協助你快速掌握這門強大的程式語言。
🚀 無論你是初學者還是經驗豐富的開發者，Rust AI Buddy 都將成為你 Coding 之旅中不可或缺的得力助手！

嘿！你今天打算解決什麼 Rust 問題？🦀

user:
{{BOT_USER_INPUT}}
